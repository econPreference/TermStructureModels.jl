<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TermStructureModels.jl</title><meta name="title" content="API · TermStructureModels.jl"/><meta property="og:title" content="API · TermStructureModels.jl"/><meta property="twitter:title" content="API · TermStructureModels.jl"/><meta name="description" content="Documentation for TermStructureModels.jl."/><meta property="og:description" content="Documentation for TermStructureModels.jl."/><meta property="twitter:description" content="Documentation for TermStructureModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TermStructureModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../notations/">Notations</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../inference/">Statistical Inference</a></li><li><a class="tocitem" href="../scenario/">Forecasting</a></li><li><a class="tocitem" href="../output/">Utilization of the Output</a></li><li><a class="tocitem" href="../others/">Other Forms of the Model</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h1><ul><li><a href="#API-documentation">API documentation</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Exported-Functions">Exported Functions</a></li><li><a href="#Internal-Functions">Internal Functions</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a></li><li><a href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a></li><li><a href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a></li><li><a href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a></li><li><a href="#TermStructureModels.Parameter_NUTS"><code>TermStructureModels.Parameter_NUTS</code></a></li><li><a href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a></li><li><a href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a></li><li><a href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a></li><li><a href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a></li><li><a href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a></li><li><a href="#Base.getindex-Tuple{Vector{&lt;:PosteriorSample}, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Statistics.mean-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.mean</code></a></li><li><a href="#Statistics.median-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.median</code></a></li><li><a href="#Statistics.quantile-Tuple{Vector{&lt;:PosteriorSample}, Any}"><code>Statistics.quantile</code></a></li><li><a href="#Statistics.std-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.std</code></a></li><li><a href="#Statistics.var-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.var</code></a></li><li><a href="#TermStructureModels.AR_res_var-Tuple{Vector, Any}"><code>TermStructureModels.AR_res_var</code></a></li><li><a href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a></li><li><a href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a></li><li><a href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a></li><li><a href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a></li><li><a href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a></li><li><a href="#TermStructureModels.Kphi-NTuple{4, Any}"><code>TermStructureModels.Kphi</code></a></li><li><a href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a></li><li><a href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a></li><li><a href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a></li><li><a href="#TermStructureModels.PCA-Tuple{Any, Any}"><code>TermStructureModels.PCA</code></a></li><li><a href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a></li><li><a href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a></li><li><a href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a></li><li><a href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a></li><li><a href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a></li><li><a href="#TermStructureModels._conditional_expectation-NTuple{6, Any}"><code>TermStructureModels._conditional_expectation</code></a></li><li><a href="#TermStructureModels._conditional_forecast-NTuple{6, Any}"><code>TermStructureModels._conditional_forecast</code></a></li><li><a href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a></li><li><a href="#TermStructureModels._unconditional_expectation-NTuple{5, Any}"><code>TermStructureModels._unconditional_expectation</code></a></li><li><a href="#TermStructureModels._unconditional_forecast-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecast</code></a></li><li><a href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a></li><li><a href="#TermStructureModels.btau-Tuple{Any}"><code>TermStructureModels.btau</code></a></li><li><a href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a></li><li><a href="#TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_mean_phi_const</code></a></li><li><a href="#TermStructureModels.conditional_expectation-Tuple{Vector, Vararg{Any, 6}}"><code>TermStructureModels.conditional_expectation</code></a></li><li><a href="#TermStructureModels.conditional_forecast-Tuple{Vector, Vararg{Any, 6}}"><code>TermStructureModels.conditional_forecast</code></a></li><li><a href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a></li><li><a href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a></li><li><a href="#TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter_NUTS}}"><code>TermStructureModels.erase_nonstationary_param</code></a></li><li><a href="#TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter}}"><code>TermStructureModels.erase_nonstationary_param</code></a></li><li><a href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a></li><li><a href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a></li><li><a href="#TermStructureModels.hessian"><code>TermStructureModels.hessian</code></a></li><li><a href="#TermStructureModels.ineff_factor-Tuple{Vector{Parameter_NUTS}}"><code>TermStructureModels.ineff_factor</code></a></li><li><a href="#TermStructureModels.ineff_factor-Tuple{Vector{Parameter}}"><code>TermStructureModels.ineff_factor</code></a></li><li><a href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a></li><li><a href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a></li><li><a href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a></li><li><a href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a></li><li><a href="#TermStructureModels.loglik_NUTS-NTuple{7, Any}"><code>TermStructureModels.loglik_NUTS</code></a></li><li><a href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a></li><li><a href="#TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}"><code>TermStructureModels.loglik_mea2</code></a></li><li><a href="#TermStructureModels.loglik_mea_NUTS-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea_NUTS</code></a></li><li><a href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a></li><li><a href="#TermStructureModels.logprior_C-Tuple{Any}"><code>TermStructureModels.logprior_C</code></a></li><li><a href="#TermStructureModels.logprior_phi0-Tuple{Any, Any, Vector, Vararg{Any, 4}}"><code>TermStructureModels.logprior_phi0</code></a></li><li><a href="#TermStructureModels.logprior_varFF-Tuple{Any}"><code>TermStructureModels.logprior_varFF</code></a></li><li><a href="#TermStructureModels.longvar-Tuple{Any}"><code>TermStructureModels.longvar</code></a></li><li><a href="#TermStructureModels.mle_error_covariance-NTuple{4, Any}"><code>TermStructureModels.mle_error_covariance</code></a></li><li><a href="#TermStructureModels.phi_2_phi₀_C-Tuple{}"><code>TermStructureModels.phi_2_phi₀_C</code></a></li><li><a href="#TermStructureModels.phi_hat-NTuple{6, Any}"><code>TermStructureModels.phi_hat</code></a></li><li><a href="#TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}"><code>TermStructureModels.phi_varFF_2_OmegaFF</code></a></li><li><a href="#TermStructureModels.phi_varFF_2_ΩPP-Tuple{}"><code>TermStructureModels.phi_varFF_2_ΩPP</code></a></li><li><a href="#TermStructureModels.post_SigmaO-Tuple{Any, Any}"><code>TermStructureModels.post_SigmaO</code></a></li><li><a href="#TermStructureModels.post_gamma-Tuple{}"><code>TermStructureModels.post_gamma</code></a></li><li><a href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a></li><li><a href="#TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ</code></a></li><li><a href="#TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ2</code></a></li><li><a href="#TermStructureModels.post_kappaQ_phi_varFF_q_nu0-NTuple{8, Any}"><code>TermStructureModels.post_kappaQ_phi_varFF_q_nu0</code></a></li><li><a href="#TermStructureModels.post_phi_varFF-NTuple{6, Any}"><code>TermStructureModels.post_phi_varFF</code></a></li><li><a href="#TermStructureModels.posterior_NUTS-NTuple{7, Any}"><code>TermStructureModels.posterior_NUTS</code></a></li><li><a href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a></li><li><a href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a></li><li><a href="#TermStructureModels.prior_gamma-Tuple{Any, Any}"><code>TermStructureModels.prior_gamma</code></a></li><li><a href="#TermStructureModels.prior_kappaQ-Tuple{Any, Any}"><code>TermStructureModels.prior_kappaQ</code></a></li><li><a href="#TermStructureModels.prior_phi0-Tuple{Any, Vector, Any, Any, Any}"><code>TermStructureModels.prior_phi0</code></a></li><li><a href="#TermStructureModels.prior_varFF-Tuple{}"><code>TermStructureModels.prior_varFF</code></a></li><li><a href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a></li><li><a href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a></li><li><a href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a></li><li><a href="#TermStructureModels.tuning_hyperparameter_with_vs-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter_with_vs</code></a></li><li><a href="#TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}"><code>TermStructureModels.yphi_Xphi</code></a></li><li><a href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a></li></ul><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TermStructureModels.Forecast"><a class="docstring-binding" href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Forecast &lt;: PosteriorSample</code></pre><p>This struct contains the results of the scenario analysis, the conditional prediction for yields, <code>factors = [PCs macros]</code>, and term premiums.</p><ul><li><code>yields</code></li><li><code>factors</code></li><li><code>TP</code>: term premium forecasts</li><li><code>EH</code>: estimated expectation hypothesis component</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L168-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Hyperparameter"><a class="docstring-binding" href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Hyperparameter</code></pre><ul><li><code>p::Int</code></li><li><code>q::Matrix</code></li><li><code>nu0</code></li><li><code>Omega0::Vector</code></li><li><code>mean_phi_const::Vector = zeros(length(Omega0))</code>: This is the prior mean of the constant term in the VAR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L9-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.LatentSpace"><a class="docstring-binding" href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct LatentSpace &lt;: PosteriorSample</code></pre><p>When the model goes to the JSZ latent factor space, the statistical parameters in struct Parameter are also transformed. This struct contains the transformed parameters. Specifically, the transformation is <code>latents[t,:] = T0P_ + inv(T1X)*PCs[t,:]</code>. </p><p>In the latent factor space, the transition equation is <code>data[t,:] = KPXF + GPXFXF*vec(data[t-1:-1:t-p,:]&#39;) + MvNormal(O,OmegaXFXF)</code>, where <code>data = [latent macros]</code>.</p><ul><li><code>latents::Matrix</code></li><li><code>kappaQ</code></li><li><code>kQ_infty</code></li><li><code>KPXF::Vector</code></li><li><code>GPXFXF::Matrix</code></li><li><code>OmegaXFXF::Matrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L98-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Parameter"><a class="docstring-binding" href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Parameter &lt;: PosteriorSample</code></pre><p>This struct contains the statistical parameters of the model that are sampled from function <code>posterior_sampler</code>.</p><ul><li><code>kappaQ</code></li><li><code>kQ_infty::Float64</code></li><li><code>phi::Matrix{Float64}</code></li><li><code>varFF::Vector{Float64}</code></li><li><code>SigmaO::Vector{Float64}</code></li><li><code>gamma::Vector{Float64}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L31-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Parameter_NUTS"><a class="docstring-binding" href="#TermStructureModels.Parameter_NUTS"><code>TermStructureModels.Parameter_NUTS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Parameter_NUTS &lt;: PosteriorSample</code></pre><p>This struct contains the statistical parameters of the model that are sampled from function <code>posterior_NUTS</code>.</p><ul><li><code>q</code></li><li><code>nu0</code></li><li><code>kappaQ</code></li><li><code>kQ_infty::Float64</code></li><li><code>phi::Matrix{Float64}</code></li><li><code>varFF::Vector{Float64}</code></li><li><code>SigmaO::Vector{Float64}</code></li><li><code>gamma::Vector{Float64}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L50-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.PosteriorSample"><a class="docstring-binding" href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type PosteriorSample</code></pre><p>This is a super-set of structs <code>Parameter</code>, <code>ReducedForm</code>, <code>LatentSpace</code>, <code>YieldCurve</code>, <code>TermPremium</code>, <code>Forecast</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L25-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.ReducedForm"><a class="docstring-binding" href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct ReducedForm &lt;: PosteriorSample</code></pre><p>This struct contains the statistical parameters in terms of the reduced form VAR(p) in P-dynamics. <code>lambdaP</code> and <code>LambdaPF</code> are parameters in the market prices of risks equation, and they only contain the first <code>dQ</code> non-zero equations. </p><ul><li><code>kappaQ</code></li><li><code>kQ_infty</code></li><li><code>KPF</code></li><li><code>GPFF</code></li><li><code>OmegaFF::Matrix</code></li><li><code>SigmaO::Vector</code></li><li><code>lambdaP</code></li><li><code>LambdaPF</code></li><li><code>mpr::Matrix(</code>market prices of risks<code>, T, dP)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L73-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Scenario"><a class="docstring-binding" href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Scenario</code></pre><p>This struct contains scenarios to be conditioned in the scenario analysis. When <code>y = [yields; macros]</code> is an observed vector in the measurement equation, <code>Scenario.combinations*y = Scenario.values</code> constitutes the scenario at a specific time. <code>Vector{Scenario}</code> is used to describe a time-series of scenarios.</p><p><code>combinations</code> and <code>values</code> should be <code>Matrix</code> and <code>Vector</code>. If <code>values</code> is a scalar, <code>combinations</code> would be a matrix with one row vector and <code>values</code> should be one-dimensional vector, for example [values]. </p><ul><li><code>combinations::Matrix</code></li><li><code>values::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L155-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.TermPremium"><a class="docstring-binding" href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct TermPremium &lt;: PosteriorSample</code></pre><p>The yields are decomposed into the term premium(<code>TP</code>) and the expectation hypothesis component(<code>EH</code>). Each component has constant terms(<code>const_TP</code> and <code>const_EH</code>) and time-varying components(<code>timevarying_TP</code> and <code>timevarying_EH</code>). <code>factorloading_EH</code> and <code>factorloading_TP</code> are coefficients of the pricing factors for the time varying components. Each column of the outputs indicates the results for each maturity.</p><p>The time-varying components are not stored in <code>TermPremium</code>, and they are the separate outputs in function <a href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>term_premium</code></a>. </p><ul><li>TP</li><li>EH</li><li>factorloading_TP</li><li>factorloading_EH</li><li>const_TP</li><li>const_EH</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L134-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.YieldCurve"><a class="docstring-binding" href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct YieldCurve &lt;: PosteriorSample</code></pre><p>This struct contains the fitted yield curve. <code>yields[t,:] = intercept + slope*latents[t,:]</code> holds.</p><ul><li><code>latents::Matrix</code>: latent pricing factors in LatentSpace</li><li><code>yields</code></li><li><code>intercept</code></li><li><code>slope</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/TermStructureModels.jl#L119-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{PosteriorSample, Symbol}"><a class="docstring-binding" href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(x::PosteriorSample, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L14-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{Vector{&lt;:PosteriorSample}, Symbol}"><a class="docstring-binding" href="#Base.getindex-Tuple{Vector{&lt;:PosteriorSample}, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(x::Vector{&lt;:PosteriorSample}, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in <code>struct</code>. <code>Output[i]</code> = the <code>i</code>-th posterior sample</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.mean-Tuple{Vector{&lt;:PosteriorSample}}"><a class="docstring-binding" href="#Statistics.mean-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mean(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L28-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.median-Tuple{Vector{&lt;:PosteriorSample}}"><a class="docstring-binding" href="#Statistics.median-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">median(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior median.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L41-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{Vector{&lt;:PosteriorSample}, Any}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{Vector{&lt;:PosteriorSample}, Any}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quantile(x::Vector{&lt;:PosteriorSample}, q)</code></pre><p><code>Output[:variable name]</code> returns a quantile of the corresponding posterior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L89-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.std-Tuple{Vector{&lt;:PosteriorSample}}"><a class="docstring-binding" href="#Statistics.std-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">std(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior standard deviation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L63-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.var-Tuple{Vector{&lt;:PosteriorSample}}"><a class="docstring-binding" href="#Statistics.var-Tuple{Vector{&lt;:PosteriorSample}}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior variance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L76-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.AR_res_var-Tuple{Vector, Any}"><a class="docstring-binding" href="#TermStructureModels.AR_res_var-Tuple{Vector, Any}"><code>TermStructureModels.AR_res_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AR_res_var(TS::Vector, p)</code></pre><p>This function derives the MLE error variance estimate of an AR(<code>p</code>) model.</p><p><strong>Input</strong></p><ul><li>Univariate time series <code>TS</code> and lag <code>p</code></li></ul><p><strong>Output(2)</strong></p><p>Residual variance estimate, AR(p) coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L673-L680">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.GQ_XX-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GQ_XX(; kappaQ)</code></pre><p><code>kappaQ</code> governs the conditional mean of the Q-dynamics of <code>X</code>, and its slope matrix has a restricted form. This function shows that restricted form.</p><p><strong>Output</strong></p><ul><li>slope matrix of the Q-conditional mean of <code>X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.LDL-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LDL(X)</code></pre><p>This function generates a matrix decomposition called LDLt. <code>X = L*D*L&#39;</code>, where <code>L</code> is a lower triangular matrix and <code>D</code> is a diagonal. How to conduct it can be found at <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition">Wikipedia</a>.</p><p><strong>Input</strong></p><ul><li>Decomposed Object, <code>X</code></li></ul><p><strong>Output(2)</strong></p><p><code>L</code>, <code>D</code></p><ul><li>Decomposed result is <code>X = L*D*L&#39;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L162-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.PCA-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.PCA-Tuple{Any, Any}"><code>TermStructureModels.PCA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PCA(yields, p; pca_loadings=[], dQ=[])</code></pre><p>This function derives the principal components from <code>yields</code>.</p><p><strong>Input</strong></p><ul><li><code>yields[p+1:end, :]</code> is used to construct the affine transformation, and then all <code>yields[:,:]</code> are transformed into the principal components.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li></ul><p><strong>Output(4)</strong></p><p><code>PCs</code>, <code>OCs</code>, <code>Wₚ</code>, <code>Wₒ</code>, <code>mean_PCs</code></p><ul><li><code>PCs</code>, <code>OCs</code>: first <code>dQ</code> and the remaining principal components</li><li><code>Wₚ</code>, <code>Wₒ</code>: the rotation matrix for <code>PCs</code> and <code>OCs</code>, respectively</li><li><code>mean_PCs</code>: the mean of <code>PCs</code> before being demeaned.</li><li><code>PCs</code> are demeaned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L653-L665">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}"><a class="docstring-binding" href="#TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_mean_phi_const</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calibrate_mean_phi_const(mean_kQ_infty, std_kQ_infty, nu0, yields, macros, tau_n, p; mean_phi_const_PCs=[], medium_tau=collect(24:3:48), iteration=1000, data_scale=1200, kappaQ_prior_pr=[], τ=[], pca_loadings=[])</code></pre><p>This function calibrates a prior mean of the first <code>dQ</code> constant terms in the VAR. Adjust your prior setting based on the prior samples in the outputs.</p><p><strong>Input</strong></p><ul><li><code>mean_phi_const_PCs</code> is your prior mean of the first <code>dQ</code> constants. The default option sets it as a zero vector.</li><li><code>iteration</code> is the number of prior samples.</li><li><code>τ::scalar</code> is a maturity for calculating the constant part in the term premium.<ul><li>If τ is empty, the function does not sample the prior distribution of the constant part in the term premium.</li></ul></li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li></ul><p><strong>Output(2)</strong></p><p><code>prior_λₚ</code>, <code>prior_TP</code></p><ul><li>samples from the prior distribution of <code>λₚ</code></li><li>prior samples of the constant part in the τ-month term premium</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L436-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.conditional_expectation-Tuple{Vector, Vararg{Any, 6}}"><a class="docstring-binding" href="#TermStructureModels.conditional_expectation-Tuple{Vector, Vararg{Any, 6}}"><code>TermStructureModels.conditional_expectation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conditional_expectation(S::Vector, τ, horizon, saved_params, yields, macros, tau_n; baseline=[], mean_macros::Vector=[], data_scale=1200, pca_loadings=[], is_parallel=false)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>Set <code>S = []</code> if you need an unconditional prediction.</li><li>If you are conditioning a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector of maturities that term premiums of interest has.</li><li><code>horizon</code>: maximum length of the predicted path. It should not be smaller than <code>length(S)</code>.</li><li><code>saved_params</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>baseline::Vector{Forecast}</code>: <code>baseline</code> is the output of <code>conditional_expectation</code>. It is generally set as the result when <code>S</code> is empty. When provided, conditional forecasts represent deviations from <code>baseline</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li><li>If <code>mean_macros</code> was used as an input when deriving <code>baseline</code> with this function, <code>mean_macros</code> should also be included as an input when using <code>baseline</code> as an input. Conversely, if <code>mean_macros</code> was not used as an input when deriving <code>baseline</code>, it should not be included as an input when using <code>baseline</code>.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>-th rows in predicted <code>yields</code>, predicted <code>factors</code>, predicted <code>TP</code>, and predicted <code>EH</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior distribution of <code>E[future obs|past obs, scenario, parameters]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L413-L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.conditional_forecast-Tuple{Vector, Vararg{Any, 6}}"><a class="docstring-binding" href="#TermStructureModels.conditional_forecast-Tuple{Vector, Vararg{Any, 6}}"><code>TermStructureModels.conditional_forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conditional_forecast(S::Vector, τ, horizon, saved_params, yields, macros, tau_n; baseline=[], mean_macros::Vector=[], data_scale=1200, pca_loadings=[], is_parallel=false)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>If we need an unconditional prediction, <code>S = []</code>.</li><li>If you are conditioning a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector. The term premium of <code>τ[i]</code>-bond is forecasted for each i.<ul><li>If <code>τ</code> is set to <code>[]</code>, the term premium is not forecasted.</li></ul></li><li><code>horizon</code>: maximum length of the predicted path. It should not be smaller than <code>length(S)</code>.</li><li><code>saved_params</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>baseline::Vector{Forecast}</code>: <code>baseline</code> is the output of <code>conditional_forecast</code>. It is generally set as the result when <code>S</code> is empty. When provided, conditional forecasts represent deviations from <code>baseline</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li><li>If <code>mean_macros</code> was used as an input when deriving <code>baseline</code> with this function, <code>mean_macros</code> should also be included as an input when using <code>baseline</code> as an input. Conversely, if <code>mean_macros</code> was not used as an input when deriving <code>baseline</code>, it should not be included as an input when using <code>baseline</code>.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>-th rows in predicted <code>yields</code>, predicted <code>factors</code>, predicted <code>TP</code>, and predicted <code>EH</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior sample from <code>future observation|past observation,scenario</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.dcurvature_dτ-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dcurvature_dτ(τ; kappaQ)</code></pre><p>This function calculates the first derivative of the curvature factor loading w.r.t. the maturity.</p><p><strong>Input</strong></p><ul><li><code>kappaQ</code>: The decay parameter</li><li><code>τ</code>: The maturity at which the derivative is calculated</li></ul><p><strong>Output</strong></p><ul><li>the first derivative of the curvature factor loading w.r.t. the maturity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L262-L270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.dimQ-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimQ()</code></pre><p>This function returns the dimension of Q-dynamics under the standard ATSM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L24-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter_NUTS}}"><a class="docstring-binding" href="#TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter_NUTS}}"><code>TermStructureModels.erase_nonstationary_param</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">erase_nonstationary_param(saved_params::Vector{Parameter_NUTS}; threshold=1)</code></pre><p>This function filters out posterior samples that imply a unit root VAR system. Only stationary posterior samples remain.</p><p><strong>Input</strong></p><ul><li><code>saved_params</code> is the output of function <code>posterior_NUTS</code>.</li><li>Posterior samples with eigenvalues of the P-system greater than <code>threshold</code> are removed.</li></ul><p><strong>Output(2):</strong></p><p>stationary samples, acceptance rate(%)</p><ul><li>The second output indicates how many posterior samples remain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L286-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter}}"><a class="docstring-binding" href="#TermStructureModels.erase_nonstationary_param-Tuple{Vector{Parameter}}"><code>TermStructureModels.erase_nonstationary_param</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">erase_nonstationary_param(saved_params::Vector{Parameter}; threshold=1)</code></pre><p>This function filters out posterior samples that imply a unit root VAR system. Only stationary posterior samples remain.</p><p><strong>Input</strong></p><ul><li><code>saved_params</code> is the first output of function <code>posterior_sampler</code>.</li><li>Posterior samples with eigenvalues of the P-system greater than <code>threshold</code> are removed.</li></ul><p><strong>Output(2):</strong></p><p>stationary samples, acceptance rate(%)</p><ul><li>The second output indicates how many posterior samples remain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L247-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><a class="docstring-binding" href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fitted_YieldCurve(τ0, saved_latent_params::Vector{LatentSpace}; data_scale=1200, is_parallel=false)</code></pre><p>This function generates the fitted yield curve.</p><p><strong>Input</strong></p><ul><li><code>τ0</code> is a set of maturities of interest. <code>τ0</code> does not need to be the same as the one used for the estimation.</li><li><code>saved_latent_params</code> is a transformed posterior sample using function <code>latentspace</code>.</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{YieldCurve}(,</code># of iteration<code>)</code></li><li><code>yields</code> and <code>latents</code> contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L584-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><a class="docstring-binding" href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generative(T, dP, tau_n, p, noise::Float64; kappaQ, kQ_infty, KPXF, GPXFXF, OmegaXFXF, data_scale=1200)</code></pre><p>This function generates simulation data given parameters. Note that all parameters are in the latent factor state space (i.e., parameters in struct LatentSpace). There are some differences in notation because it is difficult to express mathcal letters in VSCode. Therefore, mathcal{F} in the paper is expressed as <code>F</code> in VSCode, and &quot;F&quot; in the paper is expressed as <code>XF</code>.</p><p><strong>Input</strong></p><ul><li><code>noise</code>: Variance of the measurement errors</li></ul><p><strong>Output(3)</strong></p><p><code>yields</code>, <code>latents</code>, <code>macros</code></p><ul><li><code>yields = Matrix{Float64}(obs,T,length(tau_n))</code></li><li><code>latents = Matrix{Float64}(obs,T,dimQ())</code></li><li><code>macros = Matrix{Float64}(obs,T,dP - dimQ())</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L918-L928">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.hessian"><a class="docstring-binding" href="#TermStructureModels.hessian"><code>TermStructureModels.hessian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hessian(f, x, index=[])</code></pre><p>This function calculates the Hessian matrix of a scalar function <code>f</code> at <code>x</code>. If <code>index</code> is not empty, it calculates the Hessian matrix of the function with respect to the selected variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/utilities.jl#L111-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.ineff_factor-Tuple{Vector{Parameter_NUTS}}"><a class="docstring-binding" href="#TermStructureModels.ineff_factor-Tuple{Vector{Parameter_NUTS}}"><code>TermStructureModels.ineff_factor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ineff_factor(saved_params::Vector{Parameter_NUTS}; is_parallel=false)</code></pre><p>This function returns the inefficiency factors for each parameter.</p><p><strong>Input</strong></p><ul><li><code>Vector{Parameter_NUTS}</code> from <code>posterior_NUTS</code></li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li>Estimated inefficiency factors are returned as a Tuple(<code>q</code>, <code>nu0</code>, <code>kappaQ</code>, <code>kQ_infty</code>, <code>gamma</code>, <code>SigmaO</code>, <code>varFF</code>, <code>phi</code>). For example, if you want to access the inefficiency factor of <code>phi</code>, you can use <code>Output.phi</code>.</li><li>If <code>fix_const_PC1==true</code> in your optimized Hyperparameter struct, <code>Output.phi[1,1]</code> may be unreliable and should be ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L1047-L1056">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.ineff_factor-Tuple{Vector{Parameter}}"><a class="docstring-binding" href="#TermStructureModels.ineff_factor-Tuple{Vector{Parameter}}"><code>TermStructureModels.ineff_factor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ineff_factor(saved_params::Vector{Parameter}; is_parallel=false)</code></pre><p>This function returns the inefficiency factors for each parameter.</p><p><strong>Input</strong></p><ul><li><code>Vector{Parameter}</code> from <code>posterior_sampler</code></li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li>Estimated inefficiency factors are returned as a Tuple(<code>kappaQ</code>, <code>kQ_infty</code>, <code>gamma</code>, <code>SigmaO</code>, <code>varFF</code>, <code>phi</code>). For example, if you want to access the inefficiency factor of <code>phi</code>, you can use <code>Output.phi</code>.</li><li>If <code>fix_const_PC1==true</code> in your optimized Hyperparameter struct, <code>Output.phi[1,1]</code> may be unreliable and should be ignored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L959-L968">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.isstationary-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isstationary(GPFF; threshold)</code></pre><p>This function checks whether a reduced VAR matrix has unit roots. If there is at least one unit root, the return is false.</p><p><strong>Input</strong></p><ul><li><code>GPFF</code> should not include intercepts. Also, <code>GPFF</code> is a <code>dP</code> by <code>dP*p</code> matrix where the coefficient at lag 1 comes first, and the lag <code>p</code> slope matrix comes last.</li><li>Posterior samples with eigenvalues of the P-system greater than <code>threshold</code> are removed. Typically, <code>threshold</code> is set to 1.</li></ul><p><strong>Output</strong></p><ul><li><code>boolean</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L228-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.latentspace-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">latentspace(saved_params, yields, tau_n; data_scale=1200, pca_loadings=[], is_parallel=false)</code></pre><p>This function translates the principal components state space into the latent factor state space.</p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure models, theoretical yields are in decimal and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{LatentSpace}(, iteration)</code></li><li>Latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L464-L474">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_marginal(PCs, macros, rho, tuned::Hyperparameter, tau_n, Wₚ; psi=[], psi_const=[], medium_tau, kappaQ_prior_pr, fix_const_PC1)</code></pre><p>This file calculates a value of the marginal likelihood. Only the transition equation is used to calculate it.</p><p><strong>Input</strong></p><ul><li>tuned is a point where the marginal likelihood is evaluated.</li><li><code>psi_const</code> and <code>psi</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. An empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> corresponds to <code>phi[i,j]</code>.</li></ul><p><strong>Output</strong></p><ul><li>the log marginal likelihood of the VAR system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.loglik_mea-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loglik_mea(yields, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale, pca_loadings)</code></pre><p>This function generates the log likelihood of the measurement equation.</p><p><strong>Output</strong></p><ul><li>the measurement equation part of the log likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.loglik_tran-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loglik_tran(PCs, macros; phi, varFF)</code></pre><p>This function calculates the log likelihood of the transition equation.</p><p><strong>Output</strong></p><ul><li>log likelihood of the transition equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L109-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.phi_2_phi₀_C-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.phi_2_phi₀_C-Tuple{}"><code>TermStructureModels.phi_2_phi₀_C</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phi_2_phi₀_C(; phi)</code></pre><p>This function divides phi into the lagged regressor part and the contemporaneous regressor part.</p><p><strong>Output(3)</strong></p><p><code>phi0</code>, <code>C = C0 + I</code>, <code>C0</code></p><ul><li><code>phi0</code>: coefficients for the lagged regressors</li><li><code>C</code>: coefficients for the dependent variables when all contemporaneous variables are on the LHS of the orthogonalized equations. Therefore, the diagonals of <code>C</code> are ones. Note that since the contemporaneous variables get negative signs when they are on the RHS, the signs of <code>C</code> do not change whether they are on the RHS or LHS.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L198-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}"><code>TermStructureModels.phi_varFF_2_OmegaFF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phi_varFF_2_OmegaFF(; phi, varFF)</code></pre><p>This function constructs <code>OmegaFF</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>OmegaFF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L216-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.posterior_NUTS-NTuple{7, Any}"><a class="docstring-binding" href="#TermStructureModels.posterior_NUTS-NTuple{7, Any}"><code>TermStructureModels.posterior_NUTS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">posterior_NUTS(p, yields, macros, tau_n, rho, NUTS_nadapt, iteration; init_param=[], prior_q, prior_nu0, psi=[], psi_const=[], gamma_bar=[], prior_mean_diff_kappaQ, prior_std_diff_kappaQ, mean_kQ_infty=0, std_kQ_infty=0.1, fix_const_PC1=false, data_scale=1200, pca_loadings=[], NUTS_target_acceptance_rate=0.65, NUTS_max_depth=10)</code></pre><p>This function implements the NUTS-within-Gibbs sampler. Gibbs blocks that cannot be updated with conjugate priors are sampled using the NUTS sampler.</p><p><strong>Input</strong></p><ul><li><code>p</code>: The lag length of the VAR system</li><li><code>NUTS_nadapt</code>: Number of iterations for tuning settings in the NUTS sampler. The warmup samples are included in the output, so you should discard them.</li><li><code>iteration</code>: Number of posterior samples</li><li><code>init_param</code>: Starting point of the sampler. It should be of type Parameter_NUTS.</li><li><code>prior_q</code>: A 4 by 2 matrix that contains the prior distribution for q. All entries should be objects in <code>Distributions.jl</code>. For hyperparameters that do not need to be optimized, assigning a <code>Dirac(::Float64)</code> prior to the corresponding entry fixes that hyperparameter and optimizes only the remaining hyperparameters.</li><li><code>prior_nu0</code>: The prior distribution for nu0 - (dP + 1). It should be an object in <code>Distributions.jl</code>.</li><li><code>psi_const</code> and <code>psi</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. An empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> corresponds to <code>phi[i,j]</code>. The entries of <code>psi</code> and <code>psi_const</code> should be nearly zero (e.g., <code>1e-10</code>), not exactly zero.</li><li><code>prior_mean_diff_kappaQ</code> and <code>prior_std_diff_kappaQ</code> are vectors that contain the means and standard deviations of the Normal distributions for <code>[kappaQ[1]; diff(kappaQ)]</code>. Once Normal priors are assigned to these parameters, the prior for <code>kappaQ[1]</code> is truncated to (0, 1), and the priors for <code>diff(kappaQ)</code> are truncated to (−1, 0).</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li><li><code>NUTS_target_acceptance_rate</code>, <code>NUTS_max_depth</code> are the arguments of the NUTS sampler in <code>AdvancedHMC.jl</code>.</li></ul><p><strong>Output</strong></p><p><code>Vector{Parameter_NUTS}(posterior, iteration)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L826-L842">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><a class="docstring-binding" href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">posterior_sampler(yields, macros, tau_n, rho, iteration, tuned::Hyperparameter; medium_tau=collect(24:3:48), init_param=[], psi=[], psi_const=[], gamma_bar=[], kappaQ_prior_pr=[], mean_kQ_infty=0, std_kQ_infty=0.1, fix_const_PC1=false, data_scale=1200, pca_loadings=[], kappaQ_proposal_mode=[])</code></pre><p>This function samples from the posterior distribution.</p><p><strong>Input</strong></p><ul><li><code>iteration</code>: Number of posterior samples</li><li><code>tuned</code>: Optimized hyperparameters used during estimation</li><li><code>init_param</code>: Starting point of the sampler. It should be of type Parameter.</li><li><code>psi_const</code> and <code>psi</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. An empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> corresponds to <code>phi[i,j]</code>. The entries of <code>psi</code> and <code>psi_const</code> should be nearly zero (e.g., <code>1e-10</code>), not exactly zero.</li><li><code>kappaQ_prior_pr</code> is a vector of prior distributions for <code>kappaQ</code> under the JSZ model: each element specifies the prior for <code>kappaQ[i]</code> and must be provided as a <code>Distributions.jl</code> object. This option is only needed when using the JSZ model.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li><li><code>kappaQ_proposal_mode=Vector{, dQ}</code> contains the center of the proposal distribution for <code>kappaQ</code>. If it is empty, it is optimized by MLE.</li></ul><p><strong>Output(2)</strong></p><p><code>Vector{Parameter}(posterior, iteration)</code>, acceptance rate of the MH algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L693-L706">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.prior_kappaQ-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.prior_kappaQ-Tuple{Any, Any}"><code>TermStructureModels.prior_kappaQ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_kappaQ(medium_tau, pr)</code></pre><p>This function derives the maximizer decay parameter <code>kappaQ</code> that maximizes the curvature factor loading at each candidate medium-term maturity. Then, it imposes a discrete prior distribution on the maximizers with a prior probability vector <code>pr</code>.</p><p><strong>Input</strong></p><ul><li><code>medium_tau::Vector</code>(candidate medium maturities, # of candidates)</li><li><code>pr::Vector</code>(probability, # of candidates)</li></ul><p><strong>Output</strong></p><ul><li>discrete prior distribution that has a support of the maximizers <code>kappaQ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L235-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.reducedform-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reducedform(saved_params, yields, macros, tau_n; data_scale=1200, pca_loadings=[], is_parallel=false)</code></pre><p>This function converts posterior samples to the reduced form VAR parameters.</p><p><strong>Input</strong></p><ul><li><code>saved_params</code> is the first output of function <code>posterior_sampler</code>.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output</strong></p><ul><li>Posterior samples in terms of struct <code>ReducedForm</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L327-L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.term_premium-NTuple{5, Any}"><a class="docstring-binding" href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">term_premium(tau_interest, tau_n, saved_params, yields, macros; data_scale=1200, pca_loadings=[], is_parallel=false)</code></pre><p>This function generates posterior samples of the term premiums.</p><p><strong>Input</strong></p><ul><li>Maturity of interest <code>tau_interest</code> for calculating <code>TP</code></li><li><code>saved_params</code> from function <code>posterior_sampler</code></li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li><li><code>is_parallel</code> enables multi-threaded parallel computation when set to <code>true</code>.</li></ul><p><strong>Output(3)</strong></p><p><code>saved_TP</code>, <code>saved_tv_TP</code>, <code>saved_tv_EH</code></p><ul><li><code>saved_TP::Vector{TermPremium}(, iteration)</code></li><li><code>saved_tv_TP::Vector{Array}(, iteration)</code></li><li><code>saved_tv_EH::Vector{Array}(, iteration)</code></li><li>Both the term premiums and expectation hypothesis components are decomposed into the time-invariant part and time-varying part. For the maturity <code>tau_interest[i]</code> and <code>j</code>-th posterior sample, the time-varying parts are saved in <code>saved_tv_TP[j][:, :, i]</code> and <code>saved_tv_EH[j][:, :, i]</code>. The time-varying parts driven by the <code>k</code>-th pricing factor are stored in <code>saved_tv_TP[j][:, k, i]</code> and <code>saved_tv_EH[j][:, k, i]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L254-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuning_hyperparameter(yields, macros, tau_n, rho; populationsize=50, maxiter=10_000, medium_tau=collect(24:3:48), upper_q=[1 1; 1 1; 1 1; 4 4; 100 100], mean_kQ_infty=0, std_kQ_infty=0.1, upper_nu0=[], mean_phi_const=[], fix_const_PC1=false, upper_p=24, mean_phi_const_PC1=[], data_scale=1200, kappaQ_prior_pr=[], init_nu0=[], is_pure_EH=false, psi_common=[], psi_const=[], pca_loadings=[], prior_mean_diff_kappaQ=[], prior_std_diff_kappaQ=[], optimizer=:LBFGS, ml_tol=1.0, init_x=[])</code></pre><p>This function optimizes the hyperparameters by maximizing the marginal likelihood of the transition equation.</p><p><strong>Input</strong></p><ul><li>When comparing marginal likelihoods between models, the data for the dependent variable should be the same across models. To achieve this, we set the period of the dependent variable based on <code>upper_p</code>. For example, if <code>upper_p = 3</code>, <code>yields[4:end,:]</code> and <code>macros[4:end,:]</code> are the data for the dependent variable. <code>yields[1:3,:]</code> and <code>macros[1:3,:]</code> are used for setting initial observations for all lags.</li><li><code>optimizer</code>: The optimization algorithm to use.<ul><li><code>:LBFGS</code> (default): Uses unconstrained LBFGS from <code>Optim.jl</code> with hybrid parameter transformations (exp for non-negativity, sigmoid for bounded parameters). Alternates between optimizing hyperparameters (with fixed lag) and selecting the best lag (with fixed hyperparameters) until convergence.</li><li><code>:BBO</code>: Uses a differential evolutionary algorithm (BlackBoxOptim.jl). The lag and hyperparameters are optimized simultaneously.</li></ul></li><li><code>ml_tol</code>: Tolerance for parsimony in lag selection (only for <code>:LBFGS</code>). After finding the lag with the best marginal likelihood, the algorithm iteratively selects smaller lags if their marginal likelihood is within <code>ml_tol</code> of the best. This favors simpler models (smaller lags) when performance is comparable.</li><li><code>init_x</code>: Initial values for hyperparameters and lag (only for <code>:LBFGS</code>). Should be a vector of length 12 in the format <code>[vec(q); nu0-(dP+1); p]</code>. If empty (default), uses <code>[0.1, 0.1, 0.1, 2.0, 1.0, 0.1, 0.1, 0.1, 2.0, 1.0, 1.0, 1]</code>.</li><li><code>populationsize</code> and <code>maxiter</code> are options for the optimizer.<ul><li><code>populationsize</code>: the number of candidate solutions in each generation (only for <code>:BBO</code>)</li><li><code>maxiter</code>: the maximum number of iterations</li></ul></li><li>The lower bounds for <code>q</code> and <code>nu0</code> are <code>0</code> and <code>dP+2</code>.</li><li>The upper bounds for <code>q</code>, <code>nu0</code>, and VAR lag can be set by <code>upper_q</code>, <code>upper_nu0</code>, and <code>upper_p</code>.<ul><li>The default option for <code>upper_nu0</code> is the time-series length of the data.</li></ul></li><li>If you use the default option for <code>mean_phi_const</code>,<ol><li><code>mean_phi_const[dQ+1:end]</code> is a zero vector.</li><li><code>mean_phi_const[1:dQ]</code> is calibrated to make the prior mean of <code>λₚ</code> a zero vector.</li><li>After step 2, <code>mean_phi_const[1]</code> is replaced with <code>mean_phi_const_PC1</code> if it is not empty.</li></ol></li><li><code>mean_phi_const = Matrix(your prior, dP, upper_p)</code></li><li><code>mean_phi_const[:,i]</code> is the prior mean for the VAR(<code>i</code>) constant. Therefore, <code>mean_phi_const</code> is a matrix only in this function. In other functions, <code>mean_phi_const</code> is a vector for the orthogonalized VAR system with the selected lag.</li><li>When <code>fix_const_PC1==true</code>, the first element in the constant term in the orthogonalized VAR is fixed to its prior mean during posterior sampling.</li><li><code>data_scale::scalar</code>: In a typical affine term structure model, theoretical yields are in decimals and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields and use (<code>data_scale</code>*theoretical yields) as the variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li><li><code>kappaQ_prior_pr</code> is a vector of prior distributions for <code>kappaQ</code> under the JSZ model: each element specifies the prior for <code>kappaQ[i]</code> and must be provided as a <code>Distributions.jl</code> object. Alternatively, you can supply <code>prior_mean_diff_kappaQ</code> and <code>prior_std_diff_kappaQ</code>, which define means and standard deviations for Normal priors on <code>[kappaQ[1]; diff(kappaQ)]</code>; the implied Normal prior for each <code>kappaQ[i]</code> is then truncated to (0, 1). These options are only needed when using the JSZ model.</li><li><code>is_pure_EH::Bool</code>: When <code>mean_phi_const=[]</code>, <code>is_pure_EH=false</code> sets <code>mean_phi_const</code> to zero vectors. Otherwise, <code>mean_phi_const</code> is set to imply the pure expectation hypothesis under <code>mean_phi_const=[]</code>.</li><li><code>psi_const</code> and <code>psi = kron(ones(1, lag length), psi_common)</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. An empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> corresponds to <code>phi[i,j]</code>. The entries of <code>psi_common</code> and <code>psi_const</code> should be nearly zero (e.g., <code>1e-10</code>), not exactly zero.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li></ul><p><strong>Output(2)</strong></p><p>Optimized hyperparameter, optimization result</p><ul><li>Note that we minimize the negative log marginal likelihood, so the second output is for the minimization problem.</li><li>When <code>optimizer=:LBFGS</code>, the second output is a NamedTuple with fields <code>minimizer</code>, <code>minimum</code>, <code>p</code>, <code>all_minimizer</code>, <code>all_minimum</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L2-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.tuning_hyperparameter_with_vs-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.tuning_hyperparameter_with_vs-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter_with_vs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tuning_hyperparameter_with_vs(yields, macros, tau_n, rho; populationsize=50, maxiter=10_000, medium_tau=collect(24:3:48), upper_q=[1 1; 1 1; 1 1; 4 4; 100 100], mean_kQ_infty=0, std_kQ_infty=0.1, upper_nu0=[], mean_phi_const=[], fix_const_PC1=false, upper_p=24, mean_phi_const_PC1=[], data_scale=1200, kappaQ_prior_pr=[], init_nu0=[], is_pure_EH=false, psi_const=[], pca_loadings=[], prior_mean_diff_kappaQ=[], prior_std_diff_kappaQ=[], optimizer=:LBFGS, ml_tol=1.0, init_x=[])</code></pre><p>This function optimizes the hyperparameters with automatic variable selection: selects which macro variables affect latent factors (PCs).</p><p><strong>Input</strong></p><ul><li>When comparing marginal likelihoods between models, the data for the dependent variable should be the same across models. To achieve this, we set the period of the dependent variable based on <code>upper_p</code>. For example, if <code>upper_p = 3</code>, <code>yields[4:end,:]</code> and <code>macros[4:end,:]</code> are the data for the dependent variable. <code>yields[1:3,:]</code> and <code>macros[1:3,:]</code> are used for setting initial observations for all lags.</li><li><code>optimizer</code>: The optimization algorithm to use.<ul><li><code>:LBFGS</code> (default): Alternates between lag selection, forward stepwise variable selection for coefficients of macro variables on latent factors, and hyperparameter optimization. Variable selection stops when log marginal likelihood improvement ≤ 1.0.</li><li><code>:BBO</code>: Uses BlackBoxOptim.jl to optimize lag, hyperparameters, and variable selection simultaneously.</li></ul></li><li><code>ml_tol</code>: Tolerance for parsimony in lag selection (only for <code>:LBFGS</code>). After finding the lag with the best marginal likelihood, the algorithm iteratively selects smaller lags if their marginal likelihood is within <code>ml_tol</code> of the best. This favors simpler models (smaller lags) when performance is comparable.</li><li><code>init_x</code>: Initial values for hyperparameters and lag (only for <code>:LBFGS</code>). Should be a vector of length 12 in the format <code>[vec(q); nu0-(dP+1); p]</code>. If empty (default), uses <code>[0.1, 0.1, 0.1, 2.0, 1.0, 0.1, 0.1, 0.1, 2.0, 1.0, 1.0, 1]</code>.</li><li><code>populationsize</code> and <code>maxiter</code> are options for the optimizer.<ul><li><code>populationsize</code>: the number of candidate solutions in each generation (only for <code>:BBO</code>)</li><li><code>maxiter</code>: the maximum number of iterations</li></ul></li><li>The lower bounds for <code>q</code> and <code>nu0</code> are <code>0</code> and <code>dP+2</code>.</li><li>The upper bounds for <code>q</code>, <code>nu0</code>, and VAR lag can be set by <code>upper_q</code>, <code>upper_nu0</code>, and <code>upper_p</code>.<ul><li>The default option for <code>upper_nu0</code> is the time-series length of the data.</li></ul></li><li>If you use the default option for <code>mean_phi_const</code>,<ol><li><code>mean_phi_const[dQ+1:end]</code> is a zero vector.</li><li><code>mean_phi_const[1:dQ]</code> is calibrated to make the prior mean of <code>λₚ</code> a zero vector.</li><li>After step 2, <code>mean_phi_const[1]</code> is replaced with <code>mean_phi_const_PC1</code> if it is not empty.</li></ol></li><li><code>mean_phi_const = Matrix(your prior, dP, upper_p)</code></li><li><code>mean_phi_const[:,i]</code> is the prior mean for the VAR(<code>i</code>) constant. Therefore, <code>mean_phi_const</code> is a matrix only in this function. In other functions, <code>mean_phi_const</code> is a vector for the orthogonalized VAR system with the selected lag.</li><li>When <code>fix_const_PC1==true</code>, the first element in the constant term in the orthogonalized VAR is fixed to its prior mean during posterior sampling.</li><li><code>data_scale::scalar</code>: In a typical affine term structure model, theoretical yields are in decimals and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields and use (<code>data_scale</code>*theoretical yields) as the variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li><li><code>kappaQ_prior_pr</code> is a vector of prior distributions for <code>kappaQ</code> under the JSZ model: each element specifies the prior for <code>kappaQ[i]</code> and must be provided as a <code>Distributions.jl</code> object. Alternatively, you can supply <code>prior_mean_diff_kappaQ</code> and <code>prior_std_diff_kappaQ</code>, which define means and standard deviations for Normal priors on <code>[kappaQ[1]; diff(kappaQ)]</code>; the implied Normal prior for each <code>kappaQ[i]</code> is then truncated to (0, 1). These options are only needed when using the JSZ model.</li><li><code>is_pure_EH::Bool</code>: When <code>mean_phi_const=[]</code>, <code>is_pure_EH=false</code> sets <code>mean_phi_const</code> to zero vectors. Otherwise, <code>mean_phi_const</code> is set to imply the pure expectation hypothesis under <code>mean_phi_const=[]</code>.</li><li><code>psi_const</code> and <code>psi</code> (dP × dP<em>p) are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. Variable selection operates on all columns of <code>psi</code>: columns 1:dQ (lag 1 PCs) are always included, and all other columns are candidates. Setting <code>psi[1:dQ, col] = 1e-16</code> excludes a variable&#39;s effect on latent factors. For lag k, variable j, the column index is (k-1)</em>dP+j.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.</li></ul><p><strong>Output(3)</strong></p><p>Optimized hyperparameter, optimization result, psi matrix</p><ul><li>The second output contains optimization results: when <code>optimizer=:LBFGS</code>, a NamedTuple with <code>minimizer</code>, <code>minimum</code>, <code>p</code>, <code>all_minimizer</code>, <code>all_minimum</code>, <code>selected_vars</code>, <code>psi</code>; when <code>optimizer=:BBO</code>, a NamedTuple with <code>opt</code> (bboptimize result), <code>selected_vars</code>, <code>psi</code>. <code>selected_vars</code> is a sorted list of (lag, variable) tuples indicating which columns are included beyond the always-included columns 1:dQ.</li><li>The third output is <code>psi</code> (dP × dP*p), the final prior variance scaling matrix for VAR coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L274-L306">source</a></section></details></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="TermStructureModels.Aₓ-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Aₓ(aτ_, tau_n)</code></pre><p><strong>Input</strong></p><ul><li><code>aτ_</code> is an output of function <code>aτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L137-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Aₚ-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Aₚ(Aₓ_, Bₓ_, T0P_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Aₓ_</code>, <code>Bₓ_</code>, and <code>T0P_</code> are outputs of function <code>Aₓ</code>, <code>Bₓ</code>, and <code>T0P</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L159-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Bₓ-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Bₓ(bτ_, tau_n)</code></pre><p><strong>Input</strong></p><ul><li><code>bτ_</code> is an output of function <code>bτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Bₚ(Bₓ_, T1X_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> and <code>T1X_</code> are outputs of function <code>Bₓ</code> and <code>T1X</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L170-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Kphi-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.Kphi-NTuple{4, Any}"><code>TermStructureModels.Kphi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Kphi(i, V, Xphi, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L73-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Minnesota(l, i, j; q, nu0, Omega0, dQ=[])</code></pre><p>This function returns the unscaled prior variance of the Minnesota prior.</p><p><strong>Input</strong></p><ul><li>lag <code>l</code>, dependent variable <code>i</code>, regressor <code>j</code> in the VAR(<code>p</code>)</li><li><code>q[:,1]</code> and <code>q[:,2]</code> are [own, inner cross, outer cross, lag, intercept] shrinkages for the first <code>dQ</code> and remaining <code>dP-dQ</code> equations, respectively. Here, when the dependent variable is a principal component, inner cross refers to the other principal components (excluding itself), whereas outer cross refers to the macroeconomic variables. Likewise, when the dependent variable is a macroeconomic variable, inner cross refers to the other macroeconomic variables (excluding itself), whereas outer cross refers to the principal components.</li><li><code>nu0</code>(d.f.), <code>Omega0</code>(scale): Inverse-Wishart prior for the error-covariance matrix of VAR(<code>p</code>).</li></ul><p><strong>Output</strong></p><ul><li>Minnesota part in the prior variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L191-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.NIG_NIG-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NIG_NIG(y, X, β₀, B₀, α₀, δ₀)</code></pre><p>Normal-InverseGamma-Normal-InverseGamma update</p><ul><li>prior: <code>β|σ² ~ MvNormal(β₀,σ²B₀)</code>, <code>σ² ~ InverseGamma(α₀,δ₀)</code></li><li>likelihood: <code>y|β,σ² = Xβ + MvNormal(zeros(T,1),σ²I(T))</code></li></ul><p><strong>Output(2)</strong></p><p><code>β</code>, <code>σ²</code></p><ul><li>posterior sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L376-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PCs_2_latents(yields, tau_n; kappaQ, kQ_infty, KPF, GPFF, OmegaFF, data_scale, pca_loadings=[])</code></pre><p>Notation <code>XF</code> is for the latent factor space and notation <code>F</code> is for the PC state space.</p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure models, theoretical yields are in decimal and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li></ul><p><strong>Output(6)</strong></p><p><code>latent</code>, <code>kappaQ</code>, <code>kQ_infty</code>, <code>KPXF</code>, <code>GPXFXF</code>, <code>OmegaXFXF</code></p><ul><li>Latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L524-L533">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.S-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S(i; Omega0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L66-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.S_hat-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">S_hat(i, m, V, yphi, Xphi, dP; Omega0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L95-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.T0P-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T0P(T1X_, Aₓ_, Wₚ, c)</code></pre><p><strong>Input</strong></p><ul><li><code>T1X_</code> and <code>Aₓ_</code> are outputs of function <code>T1X</code> and <code>Aₓ</code>, respectively. <code>c</code> is a sample mean of <code>PCs</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T0P</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L148-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.T1X-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T1X(Bₓ_, Wₚ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> is an output of function <code>Bₓ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T1X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L71-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels._conditional_expectation-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels._conditional_expectation-NTuple{6, Any}"><code>TermStructureModels._conditional_expectation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_conditional_expectation(S, τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale, pca_loadings)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L530-L532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels._conditional_forecast-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels._conditional_forecast-NTuple{6, Any}"><code>TermStructureModels._conditional_forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_conditional_forecast(S, τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale, pca_loadings)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L183-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels._termPremium-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_termPremium(τ, PCs, macros, bτ_, T0P_, T1X_; kappaQ, kQ_infty, KPF, GPFF, ΩPP, data_scale)</code></pre><p>This function calculates the term premium for maturity <code>τ</code>.</p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code> = In typical affine term structure models, theoretical yields are in decimal and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(4)</strong></p><p><code>TP</code>, <code>timevarying_TP</code>, <code>const_TP</code>, <code>jensen</code></p><ul><li><code>TP</code>: term premium of maturity <code>τ</code></li><li><code>timevarying_TP</code>: contributions of each <code>[PCs macros]</code> on <code>TP</code> at each time <span>$t$</span> (row: time, col: variable)</li><li><code>const_TP</code>: Constant part of <code>TP</code></li><li><code>jensen</code>: Jensen&#39;s Inequality part in <code>TP</code></li><li>The output excludes the time period for the initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L181-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels._unconditional_expectation-NTuple{5, Any}"><a class="docstring-binding" href="#TermStructureModels._unconditional_expectation-NTuple{5, Any}"><code>TermStructureModels._unconditional_expectation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unconditional_expectation(τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale, pca_loadings)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L733-L735">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels._unconditional_forecast-NTuple{5, Any}"><a class="docstring-binding" href="#TermStructureModels._unconditional_forecast-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unconditional_forecast(τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale, pca_loadings)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/scenario.jl#L120-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.aτ-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">aτ(N, bτ_, tau_n, Wₚ; kQ_infty, ΩPP, data_scale)
aτ(N, bτ_; kQ_infty, ΩXX, data_scale)</code></pre><p>This function has two methods (multiple dispatch).</p><p><strong>Input</strong></p><ul><li>When <code>Wₚ</code> ∈ arguments: This function calculates <code>aτ</code> using <code>ΩPP</code>.</li><li>Otherwise: This function calculates <code>aτ</code> using <code>ΩXX = OmegaXFXF[1:dQ, 1:dQ]</code>, so parameters are in the latent factor space and <code>Wₚ</code> is not needed.</li><li><code>bτ_</code> is an output of function <code>bτ</code>.</li><li><code>data_scale::scalar</code>: In typical affine term structure models, theoretical yields are in decimal and not annualized. However, for convenience (public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use the <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector(Float64)(aτ,N)</code></li><li>For the <code>i</code>-th maturity, <code>Output[i]</code> is the corresponding <code>aτ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L82-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.btau-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.btau-Tuple{Any}"><code>TermStructureModels.btau</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">btau(N; kappaQ)</code></pre><p>This function solves the difference equation for <code>bτ</code> in the closed form expression, assuming the distinct eigenvalues under the JSZ model.</p><p><strong>Output</strong></p><ul><li>For maturity <code>i</code>, <code>btau[:, i]</code> is a vector of factor loadings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.bτ-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bτ(N; kappaQ, dQ)</code></pre><p>This function solves the difference equation for <code>bτ</code>.</p><p><strong>Output</strong></p><ul><li>For maturity <code>i</code>, <code>bτ[:, i]</code> is a vector of factor loadings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jensens_inequality(τ, bτ_, T1X_; ΩPP, data_scale)</code></pre><p>This function evaluates the Jensen&#39;s Inequality term. All terms are invariant with respect to the <code>data_scale</code>, except for this Jensen&#39;s inequality term, so the term needs to be scaled down by <code>data_scale</code>.</p><p><strong>Output</strong></p><ul><li>Jensen&#39;s Inequality term for <code>aτ</code> of maturity <code>τ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/theoreticals.jl#L122-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.loglik_NUTS-NTuple{7, Any}"><a class="docstring-binding" href="#TermStructureModels.loglik_NUTS-NTuple{7, Any}"><code>TermStructureModels.loglik_NUTS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loglik_NUTS(i, yields, PCs, tau_n, macros, dims_phi, p; phiQ, varFFQ, diff_kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale, pca_loadings)</code></pre><p>This function calculates the likelihood of the NUTS block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L344-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}"><code>TermStructureModels.loglik_mea2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loglik_mea2(yields, tau_n, p; kappaQ, kQ_infty, ΩPP, SigmaO, data_scale, pca_loadings)</code></pre><p>This function is the same as <code>loglik_mea</code> but it requires ΩPP as an input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L77-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.loglik_mea_NUTS-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.loglik_mea_NUTS-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea_NUTS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loglik_mea_NUTS(yields, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale, pca_loadings)</code></pre><p>This function generates the log likelihood of the measurement equation. It is used for <code>posterior_NUTS</code>.</p><p><strong>Output</strong></p><ul><li>the measurement equation part of the log likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L38-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.logprior_C-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.logprior_C-Tuple{Any}"><code>TermStructureModels.logprior_C</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">logprior_C(C; Omega0::Vector)</code></pre><p>This is a companion function of <code>prior_C</code>. It calculates the log density of the prior distribution for <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L58-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.logprior_phi0-Tuple{Any, Any, Vector, Vararg{Any, 4}}"><a class="docstring-binding" href="#TermStructureModels.logprior_phi0-Tuple{Any, Any, Vector, Vararg{Any, 4}}"><code>TermStructureModels.logprior_phi0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">logprior_phi0(phi0, mean_phi_const, rho::Vector, GQ_XX_mean, p, dQ, dP; psi_const, psi, q, nu0, Omega0, fix_const_PC1)</code></pre><p>This is a companion function of <code>prior_phi0</code>. It calculates the log density of the prior distribution for <code>phi0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L148-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.logprior_varFF-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.logprior_varFF-Tuple{Any}"><code>TermStructureModels.logprior_varFF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">logprior_varFF(varFF; nu0, Omega0::Vector)</code></pre><p>This is a companion function of <code>prior_varFF</code>. It calculates the log density of the prior distribution for <code>varFF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L13-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.longvar-Tuple{Any}"><a class="docstring-binding" href="#TermStructureModels.longvar-Tuple{Any}"><code>TermStructureModels.longvar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">longvar(v)</code></pre><p>This function calculates the long-run variance of <code>v</code> using the quadratic spectral window with bandwidth selection of Andrews (1991). The AR(1) approximation is used.</p><p><strong>Input</strong></p><ul><li>Time-series vector <code>v</code></li></ul><p><strong>Output</strong></p><ul><li>Estimated 2<em>π</em>h(0) of <code>v</code>, where h(x) is the spectral density of <code>v</code> at x.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L1143-L1150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.mle_error_covariance-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.mle_error_covariance-NTuple{4, Any}"><code>TermStructureModels.mle_error_covariance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mle_error_covariance(yields, macros, tau_n, p; pca_loadings=[])</code></pre><p>This function calculates the MLE estimates of the error covariance matrix of the VAR(p) model.</p><ul><li><code>pca_loadings=Matrix{, dQ, size(yields, 2)}</code> stores the loadings for the first dQ principal components (so <code>principal_components = yields * pca_loadings&#39;</code>), and you may optionally provide these loadings externally; if omitted, the package computes them internally via PCA.  ￼</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/inference.jl#L1192-L1196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.phi_hat-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels.phi_hat-NTuple{6, Any}"><code>TermStructureModels.phi_hat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phi_hat(i, m, V, yphi, Xphi, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L82-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.phi_varFF_2_ΩPP-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.phi_varFF_2_ΩPP-Tuple{}"><code>TermStructureModels.phi_varFF_2_ΩPP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">phi_varFF_2_ΩPP(; phi, varFF, dQ=[])</code></pre><p>This function constructs <code>ΩPP</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>ΩPP</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L180-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_SigmaO-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.post_SigmaO-Tuple{Any, Any}"><code>TermStructureModels.post_SigmaO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_SigmaO(yields, tau_n; kappaQ, kQ_infty, ΩPP, gamma, p, data_scale, pca_loadings)</code></pre><p>Posterior sampler for the measurement errors</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(IG, N-dQ)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L401-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_gamma-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.post_gamma-Tuple{}"><code>TermStructureModels.post_gamma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_gamma(; gamma_bar, SigmaO)</code></pre><p>Posterior sampler for the population measurement error</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(Gamma,length(SigmaO))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L434-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_kQ_infty-NTuple{4, Any}"><a class="docstring-binding" href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_kQ_infty(mean_kQ_infty, std_kQ_infty, yields, tau_n; kappaQ, phi, varFF, SigmaO, data_scale, pca_loadings)</code></pre><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_kappaQ(yields, prior_kappaQ_, tau_n; kQ_infty, phi, varFF, SigmaO, data_scale, pca_loadings)</code></pre><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is an output of function <code>prior_kappaQ</code>.</li></ul><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L53-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_kappaQ2(yields, prior_kappaQ_, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale, x_mode, inv_x_hess, pca_loadings)</code></pre><p>This function conducts the Metropolis-Hastings algorithm for the reparameterized <code>kappaQ</code> under the unrestricted JSZ form. <code>x_mode</code> and <code>inv_x_hess</code> constitute the mean and variance of the Normal proposal distribution.</p><ul><li>Reparameterization:   kappaQ[1] = x[1]   kappaQ[2] = x[1] + x[2]   kappaQ[3] = x[1] + x[2] + x[3]</li><li>Jacobian:   [1 0 0   1 1 0   1 1 1]</li><li>The determinant = 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L78-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_kappaQ_phi_varFF_q_nu0-NTuple{8, Any}"><a class="docstring-binding" href="#TermStructureModels.post_kappaQ_phi_varFF_q_nu0-NTuple{8, Any}"><code>TermStructureModels.post_kappaQ_phi_varFF_q_nu0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_kappaQ_phi_varFF_q_nu0(yields, macros, tau_n, mean_phi_const, rho, prior_q, prior_nu0, prior_diff_kappaQ; phi, psi, psi_const, varFF, q, nu0, kappaQ, kQ_infty, SigmaO, fix_const_PC1, data_scale, pca_loadings, sampler, chain, is_warmup)</code></pre><p>Full-conditional posterior sampler for <code>kappaQ</code>, <code>phi</code> and <code>varFF</code></p><p><strong>Input</strong></p><ul><li><code>prior_q</code>: The 4 by 2 matrix that contains the prior distribution for q. All entries should be objects in <code>Distributions.jl</code>.</li><li><code>prior_nu0</code>: The prior distribution for nu0 - (dP + 1). It should be an object in <code>Distributions.jl</code>.</li><li><code>prior_diff_kappaQ</code> is a vector of the truncated normals(<code>Distributions.truncated(Distributions.Normal(), lower, upper)</code>). It has a prior for <code>[kappaQ[1]; diff(kappaQ)]</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in the orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li><li><code>sampler</code> and <code>chain</code> are the objects in <code>Turing.jl</code>.</li><li>If the current step is in the warmup phase, set <code>is_warmup=true</code>.</li></ul><p><strong>Output(6)</strong></p><p>chain, q, nu0, kappaQ, phi, varFF</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L176-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.post_phi_varFF-NTuple{6, Any}"><a class="docstring-binding" href="#TermStructureModels.post_phi_varFF-NTuple{6, Any}"><code>TermStructureModels.post_phi_varFF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">post_phi_varFF(yields, macros, mean_phi_const, rho, prior_kappaQ_, tau_n; phi, psi, psi_const, varFF, q, nu0, Omega0, kappaQ, kQ_infty, SigmaO, fix_const_PC1, data_scale, pca_loadings)</code></pre><p>Full-conditional posterior sampler for <code>phi</code> and <code>varFF</code></p><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is an output of function <code>prior_kappaQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in the orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output(3)</strong></p><p><code>phi</code>, <code>varFF</code>, <code>isaccept=Vector{Bool}(undef, dQ)</code></p><ul><li>Returns a posterior sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/gibbs.jl#L125-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.prior_C-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_C(; Omega0::Vector)</code></pre><p>This function translates the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Normal priors.</p><p><strong>Output:</strong></p><ul><li>unscaled prior of <code>C</code> in the LDLt decomposition, <code>OmegaFF = inv(C)*diagm(varFF)*inv(C)&#39;</code></li></ul><p><strong>Important note</strong></p><p>prior variance for <code>C[i,:] = varFF[i]*variance of output[i,:]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L28-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.prior_gamma-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.prior_gamma-Tuple{Any, Any}"><code>TermStructureModels.prior_gamma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_gamma(yields, p; pca_loadings)</code></pre><p>There is a hierarchical structure in the measurement equation. The prior means of the measurement errors are <code>gamma[i]</code> and each <code>gamma[i]</code> follows Gamma(1,<code>gamma_bar</code>) distribution. This function decides <code>gamma_bar</code> empirically. OLS is used to estimate the measurement equation and then a variance of residuals is calculated for each maturity. An inverse of the average residual variances is set to <code>gamma_bar</code>.</p><p><strong>Output</strong></p><ul><li>hyperparameter <code>gamma_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L279-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.prior_phi0-Tuple{Any, Vector, Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.prior_phi0-Tuple{Any, Vector, Any, Any, Any}"><code>TermStructureModels.prior_phi0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_phi0(mean_phi_const, rho::Vector, prior_kappaQ_, tau_n, Wₚ; psi_const, psi, q, nu0, Omega0, fix_const_PC1)</code></pre><p>This function derives the prior distribution for coefficients of the lagged regressors in the orthogonalized VAR.</p><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is an output of function <code>prior_kappaQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in the orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output</strong></p><ul><li>Normal prior distributions on the slope coefficient of lagged variables and intercepts in the orthogonalized equation.</li><li><code>Output[:,1]</code> for intercepts, <code>Output[:,1+1:1+dP]</code> for the first lag, <code>Output[:,1+dP+1:1+2*dP]</code> for the second lag, and so on.</li></ul><p><strong>Important note</strong></p><p>prior variance for <code>phi[i,:]</code> = <code>varFF[i]*var(output[i,:])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L76-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.prior_varFF-Tuple{}"><a class="docstring-binding" href="#TermStructureModels.prior_varFF-Tuple{}"><code>TermStructureModels.prior_varFF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_varFF(; nu0, Omega0::Vector)</code></pre><p>This function translates the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Inverse-Gamma priors.</p><p><strong>Output:</strong></p><ul><li>prior of <code>varFF</code> in the LDLt decomposition,<code>OmegaFF = inv(C)*diagm(varFF)*inv(C)&#39;</code></li><li>Each element in the output follows Inverse-Gamma priors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/prior.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}"><code>TermStructureModels.yphi_Xphi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">yphi_Xphi(PCs, macros, p)</code></pre><p>This function generates the dependent variable and the corresponding regressors in the orthogonalized transition equation.</p><p><strong>Output(4)</strong></p><p><code>yphi</code>, <code>Xphi = [ones(T - p) Xphi_lag Xphi_contemporaneous]</code>, <code>[ones(T - p) Xphi_lag]</code>, <code>Xphi_contemporaneous</code></p><ul><li><code>yphi</code> and <code>Xphi</code> is a full matrix. For the i&#39;th equation, the dependent variable is <code>yphi[:,i]</code> and the regressor is <code>Xphi</code>.</li><li><code>Xphi</code> is the same for all orthogonalized transition equations. The orthogonalized equations are different in terms of contemporaneous regressors. Therefore, the corresponding regressors in <code>Xphi</code> should be excluded. The form of parameter <code>phi</code> performs that task by setting the coefficients of the excluded regressors to zeros. In particular, for the last <code>dP</code> by <code>dP</code> block in <code>phi</code>, the diagonals and the upper diagonal elements should be zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/empiricals.jl#L131-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TermStructureModels.ν-Tuple{Any, Any}"><a class="docstring-binding" href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ν(i, dP; nu0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/2d385347598659883ea9b9f329665a82333effca/src/EB_marginal.jl#L59-L61">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../others/">« Other Forms of the Model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 11:53">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
