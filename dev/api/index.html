<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TermStructureModels.jl</title><meta name="title" content="API · TermStructureModels.jl"/><meta property="og:title" content="API · TermStructureModels.jl"/><meta property="twitter:title" content="API · TermStructureModels.jl"/><meta name="description" content="Documentation for TermStructureModels.jl."/><meta property="og:description" content="Documentation for TermStructureModels.jl."/><meta property="twitter:description" content="Documentation for TermStructureModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TermStructureModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../notations/">Notations</a></li><li><a class="tocitem" href="../estimation/">Estimation</a></li><li><a class="tocitem" href="../inference/">Statistical Inference</a></li><li><a class="tocitem" href="../scenario/">Forecasting</a></li><li><a class="tocitem" href="../output/">Utilization of the Output</a></li><li><a class="tocitem" href="../others/">Other Forms of the Model</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h1><ul><li><a href="#API-documentation">API documentation</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Exported-Functions">Exported Functions</a></li><li><a href="#Internal-Functions">Internal Functions</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a></li><li><a href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a></li><li><a href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a></li><li><a href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a></li><li><a href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a></li><li><a href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a></li><li><a href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a></li><li><a href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a></li><li><a href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a></li><li><a href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.mean</code></a></li><li><a href="#Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}"><code>Statistics.median</code></a></li><li><a href="#Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}"><code>Statistics.quantile</code></a></li><li><a href="#Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.std</code></a></li><li><a href="#Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.var</code></a></li><li><a href="#TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}"><code>TermStructureModels.AR_res_var</code></a></li><li><a href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a></li><li><a href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a></li><li><a href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a></li><li><a href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a></li><li><a href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a></li><li><a href="#TermStructureModels.Kphi-NTuple{4, Any}"><code>TermStructureModels.Kphi</code></a></li><li><a href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a></li><li><a href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a></li><li><a href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a></li><li><a href="#TermStructureModels.PCA"><code>TermStructureModels.PCA</code></a></li><li><a href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a></li><li><a href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a></li><li><a href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a></li><li><a href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a></li><li><a href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a></li><li><a href="#TermStructureModels._conditional_forecasts-NTuple{6, Any}"><code>TermStructureModels._conditional_forecasts</code></a></li><li><a href="#TermStructureModels._scenario_analysis-NTuple{6, Any}"><code>TermStructureModels._scenario_analysis</code></a></li><li><a href="#TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}"><code>TermStructureModels._scenario_analysis_unconditional</code></a></li><li><a href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a></li><li><a href="#TermStructureModels._unconditional_forecasts-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecasts</code></a></li><li><a href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a></li><li><a href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a></li><li><a href="#TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_mean_phi_const</code></a></li><li><a href="#TermStructureModels.conditional_forecasts-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.conditional_forecasts</code></a></li><li><a href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a></li><li><a href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a></li><li><a href="#TermStructureModels.erase_nonstationary_param-Tuple{Any}"><code>TermStructureModels.erase_nonstationary_param</code></a></li><li><a href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a></li><li><a href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a></li><li><a href="#TermStructureModels.hessian"><code>TermStructureModels.hessian</code></a></li><li><a href="#TermStructureModels.ineff_factor-Tuple{Any}"><code>TermStructureModels.ineff_factor</code></a></li><li><a href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a></li><li><a href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a></li><li><a href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a></li><li><a href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a></li><li><a href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a></li><li><a href="#TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}"><code>TermStructureModels.loglik_mea2</code></a></li><li><a href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a></li><li><a href="#TermStructureModels.longvar-Tuple{Any}"><code>TermStructureModels.longvar</code></a></li><li><a href="#TermStructureModels.mle_error_covariance-NTuple{4, Any}"><code>TermStructureModels.mle_error_covariance</code></a></li><li><a href="#TermStructureModels.phi_2_phi₀_C-Tuple{}"><code>TermStructureModels.phi_2_phi₀_C</code></a></li><li><a href="#TermStructureModels.phi_hat-NTuple{6, Any}"><code>TermStructureModels.phi_hat</code></a></li><li><a href="#TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}"><code>TermStructureModels.phi_varFF_2_OmegaFF</code></a></li><li><a href="#TermStructureModels.phi_varFF_2_ΩPP-Tuple{}"><code>TermStructureModels.phi_varFF_2_ΩPP</code></a></li><li><a href="#TermStructureModels.post_SigmaO-Tuple{Any, Any}"><code>TermStructureModels.post_SigmaO</code></a></li><li><a href="#TermStructureModels.post_gamma-Tuple{}"><code>TermStructureModels.post_gamma</code></a></li><li><a href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a></li><li><a href="#TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ</code></a></li><li><a href="#TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ2</code></a></li><li><a href="#TermStructureModels.post_phi_varFF-NTuple{6, Any}"><code>TermStructureModels.post_phi_varFF</code></a></li><li><a href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a></li><li><a href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a></li><li><a href="#TermStructureModels.prior_gamma-Tuple{Any, Any}"><code>TermStructureModels.prior_gamma</code></a></li><li><a href="#TermStructureModels.prior_kappaQ-Tuple{Any, Any}"><code>TermStructureModels.prior_kappaQ</code></a></li><li><a href="#TermStructureModels.prior_phi0-Tuple{Any, Vector{T} where T, Any, Any, Any}"><code>TermStructureModels.prior_phi0</code></a></li><li><a href="#TermStructureModels.prior_varFF-Tuple{}"><code>TermStructureModels.prior_varFF</code></a></li><li><a href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a></li><li><a href="#TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.scenario_analysis</code></a></li><li><a href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a></li><li><a href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a></li><li><a href="#TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}"><code>TermStructureModels.yphi_Xphi</code></a></li><li><a href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a></li></ul><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Forecast" href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Forecast &lt;: PosteriorSample</code></pre><p>It contains a result of the scenario analysis, the conditional prediction for yields, <code>factors = [PCs macros]</code>, and term premiums.</p><ul><li><code>yields</code></li><li><code>factors</code></li><li><code>TP</code>: term premium forecasts</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Hyperparameter" href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Hyperparameter</code></pre><ul><li><code>p::Int</code></li><li><code>q::Matrix</code></li><li><code>nu0</code></li><li><code>Omega0::Vector</code></li><li><code>mean_phi_const::Vector = zeros(length(Omega0))</code>: It is a prior mean of a constant term in our VAR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.LatentSpace" href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct LatentSpace &lt;: PosteriorSample</code></pre><p>When the model goes to the JSZ latent factor space, the statistical parameters in struct Parameter are also transformed. This struct contains the transformed parameters. Specifically, the transformation is <code>latents[t,:] = T0P_ + inv(T1X)*PCs[t,:]</code>. </p><p>In the latent factor space, the transition equation is <code>data[t,:] = KPXF + GPXFXF*vec(data[t-1:-1:t-p,:]&#39;) + MvNormal(O,OmegaXFXF)</code>, where <code>data = [latent macros]</code>.</p><ul><li><code>latents::Matrix</code></li><li><code>kappaQ</code></li><li><code>kQ_infty</code></li><li><code>KPXF::Vector</code></li><li><code>GPXFXF::Matrix</code></li><li><code>OmegaXFXF::Matrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Parameter" href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Parameter &lt;: PosteriorSample</code></pre><p>It contains statistical parameters of the model that are sampled from function <code>posterior_sampler</code>.</p><ul><li><code>kappaQ</code></li><li><code>kQ_infty::Float64</code></li><li><code>phi::Matrix{Float64}</code></li><li><code>varFF::Vector{Float64}</code></li><li><code>SigmaO::Vector{Float64}</code></li><li><code>gamma::Vector{Float64}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PosteriorSample" href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type PosteriorSample</code></pre><p>It is a super-set of structs <code>Parameter</code>, <code>ReducedForm</code>, <code>LatentSpace</code>, <code>YieldCurve</code>, <code>TermPremium</code>, <code>Forecast</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L24-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ReducedForm" href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct ReducedForm &lt;: PosteriorSample</code></pre><p>It contains statistical parameters in terms of the reduced form VAR(p) in P-dynamics. <code>lambdaP</code> and <code>LambdaPF</code> are parameters in the market prices of risks equation, and they only contain the first <code>dQ</code> non-zero equations. </p><ul><li><code>kappaQ</code></li><li><code>kQ_infty</code></li><li><code>KPF</code></li><li><code>GPFF</code></li><li><code>OmegaFF::Matrix</code></li><li><code>SigmaO::Vector</code></li><li><code>lambdaP</code></li><li><code>LambdaPF</code></li><li><code>mpr::Matrix(</code>market prices of risks<code>, T, dP)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Scenario" href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Scenario</code></pre><p>It contains scenarios to be conditioned in the scenario analysis. When <code>y = [yields; macros]</code> is a observed vector in our measurement equation, <code>Scenario.combinations*y = Scenario.values</code> constitutes the scenario at a specific time. <code>Vector{Scenario}</code> is used to describe a time-series of scenarios.</p><p><code>combinations</code> and <code>values</code> should be <code>Matrix</code> and <code>Vector</code>. If <code>values</code> is a scalar, <code>combinations</code> would be a matrix with one raw vector and <code>values</code> should be one-dimensional vector, for example [values]. </p><ul><li><code>combinations::Matrix</code></li><li><code>values::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.TermPremium" href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct TermPremium &lt;: PosteriorSample</code></pre><p>It contains a estimated time series of a term premium for one maturity.</p><ul><li><code>TP::Vector</code>: term premium estimates of a specific maturity bond. <code>TP = timevarying_TP + const_TP + jensen</code> holds.</li><li><code>timevarying_TP::Matrix</code>: rows:time, cols:factors, values: contributions of factors on TP</li><li><code>const_TP::Float64</code>: constant part in TP</li><li><code>jensen::Float64</code>: the part due to the Jensen&#39;s inequality</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.YieldCurve" href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@kwdef struct YieldCurve &lt;: PosteriorSample</code></pre><p>It contains a fitted yield curve. <code>yields[t,:] = intercept + slope*latents[t,:]</code> holds.</p><ul><li><code>latents::Matrix</code>: latent pricing factors in LatentSpace</li><li><code>yields</code></li><li><code>intercept</code></li><li><code>slope</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/TermStructureModels.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{PosteriorSample, Symbol}" href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(x::PosteriorSample, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}" href="#Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(x::Vector{&lt;:PosteriorSample}, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in <code>struct</code>. <code>Output[i]</code> = <span>$i&#39;$</span>th posterior sample</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}" href="#Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">median(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior median.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}" href="#Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quantile(x::Vector{&lt;:PosteriorSample}, q)</code></pre><p><code>Output[:variable name]</code> returns a quantile of the corresponding posterior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">std(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior standard deviation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">var(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior variance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}" href="#TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}"><code>TermStructureModels.AR_res_var</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AR_res_var(TS::Vector, p)</code></pre><p>It derives an MLE error variance estimate of an AR(<code>p</code>) model</p><p><strong>Input</strong></p><ul><li>univariate time series <code>TS</code> and the lag <code>p</code></li></ul><p><strong>output(2)</strong></p><p>residual variance estimate, AR(p) coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L136-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.GQ_XX-Tuple{}" href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GQ_XX(; kappaQ)</code></pre><p><code>kappaQ</code> governs a conditional mean of the Q-dynamics of <code>X</code>, and its slope matrix has a restricted form. This function shows that restricted form.</p><p><strong>Output</strong></p><ul><li>slope matrix of the Q-conditional mean of <code>X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.LDL-Tuple{Any}" href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LDL(X)</code></pre><p>This function generate a matrix decomposition, called LDLt. <code>X = L*D*L&#39;</code>, where <code>L</code> is a lower triangular matrix and <code>D</code> is a diagonal. How to conduct it can be found at <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition">Wikipedia</a>.</p><p><strong>Input</strong></p><ul><li>Decomposed Object, <code>X</code></li></ul><p><strong>Output(2)</strong></p><p><code>L</code>, <code>D</code></p><ul><li>Decomposed result is <code>X = L*D*L&#39;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L123-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PCA" href="#TermStructureModels.PCA"><code>TermStructureModels.PCA</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PCA(yields, p, proxies=[]; rescaling=false, dQ=[])</code></pre><p>It derives the principal components from <code>yields</code>.</p><p><strong>Input</strong></p><ul><li><code>yields[p+1:end, :]</code> is used to construct the affine transformation, and then all <code>yields[:,:]</code> are transformed into the principal components.</li><li>Since signs of <code>PCs</code> is not identified, we use proxies to identify the signs. We flip <code>PCs</code> to make <code>cor(proxies[:, i]. PCs[:,i]) &gt; 0</code>. If <code>proxies</code> is not given, we use the following proxies as a default: <code>[yields[:, end] yields[:, end] - yields[:, 1] 2yields[:, Int(floor(size(yields, 2) / 3))] - yields[:, 1] - yields[:, end]]</code>.</li><li><code>size(proxies) = (size(yields[p+1:end, :], 1), dQ)</code></li><li>If <code>rescaling == true</code>, all <code>PCs</code> and <code>OCs</code> are normalized to have an average std of yields.</li></ul><p><strong>Output(4)</strong></p><p><code>PCs</code>, <code>OCs</code>, <code>Wₚ</code>, <code>Wₒ</code>, <code>mean_PCs</code></p><ul><li><code>PCs</code>, <code>OCs</code>: first <code>dQ</code> and the remaining principal components</li><li><code>Wₚ</code>, <code>Wₒ</code>: the rotation matrix for <code>PCs</code> and <code>OCs</code>, respectively</li><li><code>mean_PCs</code>: the mean of <code>PCs</code> before demeaned.</li><li><code>PCs</code> are demeaned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L432-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}" href="#TermStructureModels.calibrate_mean_phi_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_mean_phi_const</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_mean_phi_const(mean_kQ_infty, std_kQ_infty, nu0, yields, macros, tau_n, p; mean_phi_const_PCs=[], medium_tau=collect(24:3:48), iteration=1000, data_scale=1200, kappaQ_prior_pr=[], τ=[])</code></pre><p>The purpose of the function is to calibrate a prior mean of the first <code>dQ</code> constant terms in our VAR. Adjust your prior setting based on the prior samples in outputs.</p><p><strong>Input</strong></p><ul><li><code>mean_phi_const_PCs</code> is your prior mean of the first <code>dQ</code> constants. Our default option set it as a zero vector.</li><li><code>iteration</code> is the number of prior samples.</li><li><code>τ::scalar</code> is a maturity for calculating the constant part in the term premium.<ul><li>If τ is empty, the function does not sampling the prior distribution of the constant part in the term premium.</li></ul></li></ul><p><strong>Output(2)</strong></p><p><code>prior_λₚ</code>, <code>prior_TP</code></p><ul><li>samples from the prior distribution of <code>λₚ</code> </li><li>prior samples of constant part in the τ-month term premium</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L313-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.conditional_forecasts-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}" href="#TermStructureModels.conditional_forecasts-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.conditional_forecasts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conditional_forecasts(S::Vector, τ, horizon, saved_params, yields, macros, tau_n; mean_macros::Vector=[], data_scale=1200)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>If we need an unconditional prediction, <code>S = []</code>.</li><li>If you are conditionaing a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector. The term premium of <code>τ[i]</code>-bond is forecasted for each i.<ul><li>If <code>τ</code> is set to <code>[]</code>, the term premium is not forecasted. </li></ul></li><li><code>horizon</code>: maximum length of the predicted path. It should not be small than <code>length(S)</code>.</li><li><code>saved_params</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>&#39;th rows in predicted <code>yields</code>, predicted <code>factors</code>, and predicted <code>TP</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior samples from <code>future observation|past observation,scenario</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.dcurvature_dτ-Tuple{Any}" href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcurvature_dτ(τ; kappaQ)</code></pre><p>This function calculate the first derivative of the curvature factor loading w.r.t. the maturity.</p><p><strong>Input</strong></p><ul><li><code>kappaQ</code>: The decay parameter</li><li><code>τ</code>: The maturity that the derivative is calculated</li></ul><p><strong>Output</strong></p><ul><li>the first derivative of the curvature factor loading w.r.t. the maturity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.dimQ-Tuple{}" href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimQ()</code></pre><p>It returns the dimension of Q-dynamics under the standard ATSM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.erase_nonstationary_param-Tuple{Any}" href="#TermStructureModels.erase_nonstationary_param-Tuple{Any}"><code>TermStructureModels.erase_nonstationary_param</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">erase_nonstationary_param(saved_params; threshold=1)</code></pre><p>It filters out posterior samples that implies an unit root VAR system. Only stationary posterior samples remain.</p><p><strong>Input</strong></p><ul><li><code>saved_params</code> is the first output of function <code>posterior_sampler</code>.</li><li>Posterior samples with eigenvalues of the P-system greater than <code>threshold</code> are removed. </li></ul><p><strong>Output(2):</strong></p><p>stationary samples, acceptance rate(%)</p><ul><li>The second output indicates how many posterior samples remain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L208-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}" href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fitted_YieldCurve(τ0, saved_latent_params::Vector{LatentSpace}; data_scale=1200)</code></pre><p>It generates a fitted yield curve.</p><p><strong>Input</strong></p><ul><li><code>τ0</code> is a set of maturities of interest. <code>τ0</code> does not need to be the same as the one used for the estimation.</li><li><code>saved_latent_params</code> is a transformed posterior sample using function <code>latentspace</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{YieldCurve}(,</code># of iteration<code>)</code></li><li><code>yields</code> and <code>latents</code> contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L389-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}" href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generative(T, dP, tau_n, p, noise::Float64; kappaQ, kQ_infty, KPXF, GPXFXF, OmegaXFXF, data_scale=1200)</code></pre><p>This function generate a simulation data given parameters. Note that all parameters are the things in the latent factor state space (that is, parameters in struct LatentSpace). There is some differences in notations because it is hard to express mathcal letters in VScode. So, mathcal{F} in my paper is expressed in <code>F</code> in the VScode. And, &quot;F&quot; in my paper is expressed as <code>XF</code>.</p><p><strong>Input:</strong></p><ul><li>noise = variance of the measurement errors</li></ul><p><strong>Output(3)</strong></p><p><code>yields</code>, <code>latents</code>, <code>macros</code></p><ul><li><code>yields = Matrix{Float64}(obs,T,length(tau_n))</code></li><li><code>latents = Matrix{Float64}(obs,T,dimQ())</code></li><li><code>macros = Matrix{Float64}(obs,T,dP - dimQ())</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L279-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.hessian" href="#TermStructureModels.hessian"><code>TermStructureModels.hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hessian(f, x, index=[])</code></pre><p>It calculates the Hessian matrix of a scalar function <code>f</code> at <code>x</code>. If <code>index</code> is not empty, it calculates the Hessian matrix of the function with respect to the selected variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/utilities.jl#L100-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ineff_factor-Tuple{Any}" href="#TermStructureModels.ineff_factor-Tuple{Any}"><code>TermStructureModels.ineff_factor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ineff_factor(saved_params)</code></pre><p>It returns inefficiency factors of each parameter.</p><p><strong>Input</strong></p><ul><li><code>Vector{Parameter}</code> from <code>posterior_sampler</code></li></ul><p><strong>Output</strong></p><ul><li>Estimated inefficiency factors are in Tuple(<code>kappaQ</code>, <code>kQ_infty</code>, <code>gamma</code>, <code>SigmaO</code>, <code>varFF</code>, <code>phi</code>). For example, if you want to load an inefficiency factor of <code>phi</code>, you can use <code>Output.phi</code>.</li><li>If <code>fix_const_PC1==true</code> in your optimized struct Hyperparameter, <code>Output.phi[1,1]</code> can be weird. So you should ignore it.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L320-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.isstationary-Tuple{Any}" href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isstationary(GPFF; threshold)</code></pre><p>It checks whether a reduced VAR matrix has unit roots. If there is at least one unit root, return is false.</p><p><strong>Input</strong></p><ul><li><code>GPFF</code> should not include intercepts. Also, <code>GPFF</code> is <code>dP</code> by <code>dP*p</code> matrix that the coefficient at lag 1 comes first, and the lag <code>p</code> slope matrix comes last. </li><li>Posterior samples with eigenvalues of the P-system greater than <code>threshold</code> are removed. Typically, <code>threshold</code> is set to 1.</li></ul><p><strong>Output</strong></p><ul><li><code>boolean</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L189-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.latentspace-Tuple{Any, Any, Any}" href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">latentspace(saved_params, yields, tau_n; data_scale=1200)</code></pre><p>This function translates the principal components state space into the latent factor state space. </p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{LatentSpace}(, iteration)</code></li><li>latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L293-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}" href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log_marginal(PCs, macros, rho, tuned::Hyperparameter, tau_n, Wₚ; psi=[], psi_const=[], medium_tau, kappaQ_prior_pr, fix_const_PC1)</code></pre><p>This file calculates a value of our marginal likelihood. Only the transition equation is used to calculate it. </p><p><strong>Input</strong></p><ul><li>tuned is a point where the marginal likelihood is evaluated. 	</li><li><code>psi_const</code> and <code>psi</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. A empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> is corresponds to <code>phi[i,j]</code>. </li></ul><p><strong>Output</strong></p><ul><li>the log marginal likelihood of the VAR system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.loglik_mea-Tuple{Any, Any}" href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglik_mea(yields, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale)</code></pre><p>This function generate a log likelihood of the measurement equation.</p><p><strong>Output</strong></p><ul><li>the measurement equation part of the log likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.loglik_tran-Tuple{Any, Any}" href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglik_tran(PCs, macros; phi, varFF)</code></pre><p>It calculate log likelihood of the transition equation. </p><p><strong>Output</strong></p><ul><li>log likelihood of the transition equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.phi_2_phi₀_C-Tuple{}" href="#TermStructureModels.phi_2_phi₀_C-Tuple{}"><code>TermStructureModels.phi_2_phi₀_C</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi_2_phi₀_C(; phi)</code></pre><p>It divide phi into the lagged regressor part and the contemporaneous regerssor part.</p><p><strong>Output(3)</strong></p><p><code>phi0</code>, <code>C = C0 + I</code>, <code>C0</code></p><ul><li><code>phi0</code>: coefficients for the lagged regressors</li><li><code>C</code>: coefficients for the dependent variables when all contemporaneous variables are in the LHS of the orthogonalized equations. Therefore, the diagonals of <code>C</code> is ones. Note that since the contemporaneous variables get negative signs when they are at the RHS, the signs of <code>C</code> do not change whether they are at the RHS or LHS. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}" href="#TermStructureModels.phi_varFF_2_OmegaFF-Tuple{}"><code>TermStructureModels.phi_varFF_2_OmegaFF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi_varFF_2_OmegaFF(; phi, varFF)</code></pre><p>It construct <code>OmegaFF</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>OmegaFF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}" href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posterior_sampler(yields, macros, tau_n, rho, iteration, tuned::Hyperparameter; medium_tau=collect(24:3:48), init_param=[], psi=[], psi_const=[], gamma_bar=[], kappaQ_prior_pr=[], mean_kQ_infty=0, std_kQ_infty=0.1, fix_const_PC1=false, data_scale=1200)</code></pre><p>This is a posterior distribution sampler.</p><p><strong>Input</strong></p><ul><li><code>iteration</code>: # of posterior samples</li><li><code>tuned</code>: optimized hyperparameters used during estimation</li><li><code>init_param</code>: starting point of the sampler. It should be a type of Parameter.</li><li><code>psi_const</code> and <code>psi</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. A empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> is corresponds to <code>phi[i,j]</code>. The entries of <code>psi</code> and <code>psi_const</code> should be nearly zero(e.g., <code>1e-10</code>), not exactly zero.</li></ul><p><strong>Output(2)</strong></p><p><code>Vector{Parameter}(posterior, iteration)</code>, acceptance rate of the MH algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_kappaQ-Tuple{Any, Any}" href="#TermStructureModels.prior_kappaQ-Tuple{Any, Any}"><code>TermStructureModels.prior_kappaQ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prior_kappaQ(medium_tau, pr)</code></pre><p>The function derive the maximizer decay parameter <code>kappaQ</code> that maximize the curvature factor loading at each candidate medium-term maturity. And then, it impose a discrete prior distribution on the maximizers with a prior probability vector <code>pr</code>.</p><p><strong>Input</strong></p><ul><li><code>medium_tau::Vector</code>(candidate medium maturities, # of candidates)</li><li><code>pr::Vector</code>(probability, # of candidates)</li></ul><p><strong>Output</strong></p><ul><li>discrete prior distribution that has a support of the maximizers <code>kappaQ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.reducedform-NTuple{4, Any}" href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reducedform(saved_params, yields, macros, tau_n; data_scale=1200)</code></pre><p>It converts posterior samples in terms of the reduced form VAR parameters.</p><p><strong>Input</strong></p><ul><li><code>saved_params</code> is the first output of function <code>posterior_sampler</code>.</li></ul><p><strong>Output</strong></p><ul><li>Posterior samples in terms of struct <code>ReducedForm</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}" href="#TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.scenario_analysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scenario_analysis(S::Vector, τ, horizon, saved_params, yields, macros, tau_n; mean_macros::Vector=[], data_scale=1200)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>Set <code>S = []</code> if you need an unconditional prediction. </li><li>If you are conditionaing a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector of maturities that term premiums of interest has.</li><li><code>horizon</code>: maximum length of the predicted path. It should not be small than <code>length(S)</code>.</li><li><code>saved_params</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>&#39;th rows in predicted <code>yields</code>, predicted <code>factors</code>, and predicted <code>TP</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior distribution of <code>E[future obs|past obs, scenario, parameters]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L312-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.term_premium-NTuple{5, Any}" href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">term_premium(τ, tau_n, saved_params, yields, macros; data_scale=1200)</code></pre><p>This function generates posterior samples of the term premiums.</p><p><strong>Input</strong></p><ul><li>maturity of interest <code>τ</code> for Calculating <code>TP</code></li><li><code>saved_params</code> from function <code>posterior_sampler</code></li></ul><p><strong>Output</strong></p><ul><li><code>Vector{TermPremium}(, iteration)</code></li><li>Outputs exclude initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L240-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.tuning_hyperparameter-NTuple{4, Any}" href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tuning_hyperparameter(yields, macros, tau_n, rho; populationsize=50, maxiter=10_000, medium_tau=collect(24:3:48), upper_q=[1 1; 1 1; 10 10; 100 100], mean_kQ_infty=0, std_kQ_infty=0.1, upper_nu0=[], mean_phi_const=[], fix_const_PC1=false, upper_p=18, mean_phi_const_PC1=[], data_scale=1200, kappaQ_prior_pr=[], init_nu0=[], is_pure_EH=false, psi_common=[], psi_const=[])</code></pre><p>It optimizes our hyperparameters by maximizing the marginal likelhood of the transition equation. Our optimizer is a differential evolutionary algorithm that utilizes bimodal movements in the eigen-space(Wang, Li, Huang, and Li, 2014) and the trivial geography(Spector and Klein, 2006).</p><p><strong>Input</strong></p><ul><li>When we compare marginal likelihoods between models, the data for the dependent variable should be the same across the models. To achieve that, we set a period of dependent variable based on <code>upper_p</code>. For example, if <code>upper_p = 3</code>, <code>yields[4:end,:]</code> and <code>macros[4:end,:]</code> are the data for our dependent variable. <code>yields[1:3,:]</code> and <code>macros[1:3,:]</code> are used for setting initial observations for all lags.</li><li><code>populationsize</code> and <code>maxiter</code> are options for the optimizer.<ul><li><code>populationsize</code>: the number of candidate solutions in each generation</li><li><code>maxtier</code>: the maximum number of iterations</li></ul></li><li>The lower bounds for <code>q</code> and <code>nu0</code> are <code>0</code> and <code>dP+2</code>. </li><li>The upper bounds for <code>q</code>, <code>nu0</code> and VAR lag can be set by <code>upper_q</code>, <code>upper_nu0</code>, <code>upper_p</code>.<ul><li>Our default option for <code>upper_nu0</code> is the time-series length of the data.</li></ul></li><li>If you use our default option for <code>mean_phi_const</code>,<ol><li><code>mean_phi_const[dQ+1:end]</code> is a zero vector.</li><li><code>mean_phi_const[1:dQ]</code> is calibrated to make a prior mean of <code>λₚ</code> a zero vector.</li><li>After step 2, <code>mean_phi_const[1]</code> is replaced with <code>mean_phi_const_PC1</code> if it is not empty.</li></ol></li><li><code>mean_phi_const = Matrix(your prior, dP, upper_p)</code> </li><li><code>mean_phi_const[:,i]</code> is a prior mean for the VAR(<code>i</code>) constant. Therefore <code>mean_phi_const</code> is a matrix only in this function. In other functions, <code>mean_phi_const</code> is a vector for the orthogonalized VAR system with your selected lag.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li><li><code>is_pure_EH::Bool</code>: When <code>mean_phi_const=[]</code>, <code>is_pure_EH=false</code> sets <code>mean_phi_const</code> to zero vectors. Otherwise, <code>mean_phi_const</code> is set to imply the pure expectation hypothesis under <code>mean_phi_const=[]</code>.</li><li><code>psi_const</code> and <code>psi = kron(ones(1, lag length), psi_common)</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. A empty default value means that you do not use this function. <code>[psi_const psi][i,j]</code> is corresponds to <code>phi[i,j]</code>. The entries of <code>psi_common</code> and <code>psi_const</code> should be nearly zero(e.g., <code>1e-10</code>), not exactly zero.</li></ul><p><strong>Output(2)</strong></p><p>optimized Hyperparameter, optimization result</p><ul><li>Be careful that we minimized the negative log marginal likelihood, so the second output is about the minimization problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L2-L26">source</a></section></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Aₓ-Tuple{Any, Any}" href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Aₓ(aτ_, tau_n)</code></pre><p><strong>Input</strong></p><ul><li><code>aτ_</code> is an output of function <code>aτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Aₚ-NTuple{4, Any}" href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Aₚ(Aₓ_, Bₓ_, T0P_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Aₓ_</code>, <code>Bₓ_</code>, and <code>T0P_</code> are outputs of function <code>Aₓ</code>, <code>Bₓ</code>, and <code>T0P</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L145-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Bₓ-Tuple{Any, Any}" href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bₓ(bτ_, tau_n)</code></pre><p><strong>Input</strong></p><ul><li><code>bτ_</code> is an output of function <code>bτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Bₚ-Tuple{Any, Any, Any}" href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bₚ(Bₓ_, T1X_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> and <code>T1X_</code> are outputs of function <code>Bₓ</code> and <code>T1X</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Kphi-NTuple{4, Any}" href="#TermStructureModels.Kphi-NTuple{4, Any}"><code>TermStructureModels.Kphi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kphi(i, V, Xphi, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Minnesota-Tuple{Any, Any, Any}" href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minnesota(l, i, j; q, nu0, Omega0, dQ=[])</code></pre><p>It return unscaled prior variance of the Minnesota prior.</p><p><strong>Input</strong></p><ul><li>lag <code>l</code>, dependent variable <code>i</code>, regressor <code>j</code> in the VAR(<code>p</code>)</li><li><code>q[:,1]</code> and <code>q[:,2]</code> are [own, cross, lag, intercept] shrikages for the first <code>dQ</code> and remaining <code>dP-dQ</code> equations, respectively.</li><li><code>nu0</code>(d.f.), <code>Omega0</code>(scale): Inverse-Wishart prior for the error-covariance matrix of VAR(<code>p</code>).</li></ul><p><strong>Output</strong></p><ul><li>Minnesota part in the prior variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L122-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.NIG_NIG-NTuple{6, Any}" href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NIG_NIG(y, X, β₀, B₀, α₀, δ₀)</code></pre><p>Normal-InverseGamma-Normal-InverseGamma update</p><ul><li>prior: <code>β|σ² ~ MvNormal(β₀,σ²B₀)</code>, <code>σ² ~ InverseGamma(α₀,δ₀)</code></li><li>likelihood: <code>y|β,σ² = Xβ + MvNormal(zeros(T,1),σ²I(T))</code></li></ul><p><strong>Output(2)</strong></p><p><code>β</code>, <code>σ²</code></p><ul><li>posterior sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PCs_2_latents-Tuple{Any, Any}" href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PCs_2_latents(yields, tau_n; kappaQ, kQ_infty, KPF, GPFF, OmegaFF, data_scale)</code></pre><p>Notation <code>XF</code> is for the latent factor space and notation <code>F</code> is for the PC state space.</p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(6)</strong></p><p><code>latent</code>, <code>kappaQ</code>, <code>kQ_infty</code>, <code>KPXF</code>, <code>GPXFXF</code>, <code>OmegaXFXF</code></p><ul><li>latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L330-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.S-Tuple{Any}" href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S(i; Omega0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.S_hat-NTuple{6, Any}" href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S_hat(i, m, V, yphi, Xphi, dP; Omega0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L95-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.T0P-NTuple{4, Any}" href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T0P(T1X_, Aₓ_, Wₚ, c)</code></pre><p><strong>Input</strong></p><ul><li><code>T1X_</code> and <code>Aₓ_</code> are outputs of function <code>T1X</code> and <code>Aₓ</code>, respectively. <code>c</code> is a sample mean of <code>PCs</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T0P</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.T1X-Tuple{Any, Any}" href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T1X(Bₓ_, Wₚ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> if an output of function <code>Bₓ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T1X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._conditional_forecasts-NTuple{6, Any}" href="#TermStructureModels._conditional_forecasts-NTuple{6, Any}"><code>TermStructureModels._conditional_forecasts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_conditional_forecasts(S, τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._scenario_analysis-NTuple{6, Any}" href="#TermStructureModels._scenario_analysis-NTuple{6, Any}"><code>TermStructureModels._scenario_analysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_scenario_analysis(S, τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L354-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}" href="#TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}"><code>TermStructureModels._scenario_analysis_unconditional</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_scenario_analysis_unconditional(τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L526-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._termPremium-NTuple{6, Any}" href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_termPremium(τ, PCs, macros, bτ_, T0P_, T1X_; kappaQ, kQ_infty, KPF, GPFF, ΩPP, data_scale)</code></pre><p>This function calculates a term premium for maturity <code>τ</code>. </p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code> = In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(4)</strong></p><p><code>TP</code>, <code>timevarying_TP</code>, <code>const_TP</code>, <code>jensen</code></p><ul><li><code>TP</code>: term premium of maturity <code>τ</code></li><li><code>timevarying_TP</code>: contributions of each <code>[PCs macros]</code> on <code>TP</code> at each time <span>$t$</span> (row: time, col: variable)</li><li><code>const_TP</code>: Constant part of <code>TP</code></li><li><code>jensen</code>: Jensen&#39;s Ineqaulity part in <code>TP</code></li><li>Output excludes the time period for the initial observations.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L167-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._unconditional_forecasts-NTuple{5, Any}" href="#TermStructureModels._unconditional_forecasts-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecasts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_unconditional_forecasts(τ, horizon, yields, macros, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/scenario.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.aτ-NTuple{4, Any}" href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">aτ(N, bτ_, tau_n, Wₚ; kQ_infty, ΩPP, data_scale)
aτ(N, bτ_; kQ_infty, ΩXX, data_scale)</code></pre><p>The function has two methods(multiple dispatch). </p><p><strong>Input</strong></p><ul><li>When <code>Wₚ</code> ∈ arguments: It calculates <code>aτ</code> using <code>ΩPP</code>. </li><li>Otherwise: It calculates <code>aτ</code> using <code>ΩXX = OmegaXFXF[1:dQ, 1:dQ]</code>, so parameters are in the latent factor space. So, we do not need <code>Wₚ</code>.</li><li><code>bτ_</code> is an output of function <code>bτ</code>.</li><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector(Float64)(aτ,N)</code></li><li>For <code>i</code>&#39;th maturity, <code>Output[i]</code> is the corresponding <code>aτ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L68-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.bτ-Tuple{Any}" href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bτ(N; kappaQ, dQ)</code></pre><p>It solves the difference equation for <code>bτ</code>.</p><p><strong>Output</strong></p><ul><li>for maturity <code>i</code>, <code>bτ[:, i]</code> is a vector of factor loadings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}" href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jensens_inequality(τ, bτ_, T1X_; ΩPP, data_scale)</code></pre><p>This function evaluate the Jensen&#39;s Ineqaulity term. All term is invariant with respect to the <code>data_scale</code>, except for this Jensen&#39;s inequality term. So, we need to scale down the term by <code>data_scale</code>.</p><p><strong>Output</strong></p><ul><li>Jensen&#39;s Ineqaulity term for <code>aτ</code> of maturity <code>τ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/theoreticals.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}" href="#TermStructureModels.loglik_mea2-Tuple{Any, Any, Any}"><code>TermStructureModels.loglik_mea2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglik_mea2(yields, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale)</code></pre><p>This function is the same as <code>loglik_mea</code> but it requires ΩPP as an input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.longvar-Tuple{Any}" href="#TermStructureModels.longvar-Tuple{Any}"><code>TermStructureModels.longvar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">longvar(v)</code></pre><p>It calculates the long-run variance of <code>v</code> using the quadratic spectral window with selection of bandwidth of Andrews(1991). We use the AR(1) approximation.</p><p><strong>Input</strong></p><ul><li>Time-series Vector <code>v</code></li></ul><p><strong>Output</strong></p><ul><li>Estimated 2<em>π</em>h(0) of <code>v</code>, where h(x) is the spectral density of <code>v</code> at x.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L386-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.mle_error_covariance-NTuple{4, Any}" href="#TermStructureModels.mle_error_covariance-NTuple{4, Any}"><code>TermStructureModels.mle_error_covariance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mle_error_covariance(yields, macros, tau_n, p)</code></pre><p>It calculates the MLE estimates of the error covariance matrix of the VAR(p) model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/inference.jl#L435-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.phi_hat-NTuple{6, Any}" href="#TermStructureModels.phi_hat-NTuple{6, Any}"><code>TermStructureModels.phi_hat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi_hat(i, m, V, yphi, Xphi, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.phi_varFF_2_ΩPP-Tuple{}" href="#TermStructureModels.phi_varFF_2_ΩPP-Tuple{}"><code>TermStructureModels.phi_varFF_2_ΩPP</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">phi_varFF_2_ΩPP(; phi, varFF, dQ=[])</code></pre><p>It construct <code>ΩPP</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>ΩPP</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_SigmaO-Tuple{Any, Any}" href="#TermStructureModels.post_SigmaO-Tuple{Any, Any}"><code>TermStructureModels.post_SigmaO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_SigmaO(yields, tau_n; kappaQ, kQ_infty, ΩPP, gamma, p, data_scale)</code></pre><p>Posterior sampler for the measurement errors</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(IG, N-dQ)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_gamma-Tuple{}" href="#TermStructureModels.post_gamma-Tuple{}"><code>TermStructureModels.post_gamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_gamma(; gamma_bar, SigmaO)</code></pre><p>Posterior sampler for the population measurement error</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(Gamma,length(SigmaO))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_kQ_infty-NTuple{4, Any}" href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_kQ_infty(mean_kQ_infty, std_kQ_infty, yields, tau_n; kappaQ, phi, varFF, SigmaO, data_scale)</code></pre><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}" href="#TermStructureModels.post_kappaQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_kappaQ(yields, prior_kappaQ_, tau_n; kQ_infty, phi, varFF, SigmaO, data_scale)</code></pre><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is a output of function <code>prior_kappaQ</code>.</li></ul><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}" href="#TermStructureModels.post_kappaQ2-Tuple{Any, Any, Any}"><code>TermStructureModels.post_kappaQ2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_kappaQ2(yields, prior_kappaQ_, tau_n; kappaQ, kQ_infty, phi, varFF, SigmaO, data_scale, x_mode, inv_x_hess)</code></pre><p>It conducts the Metropolis-Hastings algorithm for the reparameterized <code>kappaQ</code> under the unrestricted JSZ form. <code>x_mode</code> and <code>inv_x_hess</code> constitute the mean and variance of the Normal proposal distribution.</p><ul><li>Reparameterization:   kappaQ[1] = x[1]   kappaQ[2] = x[1] + x[2]   kappaQ[3] = x[1] + x[2] + x[3]</li><li>Jacobian:   [1 0 0   1 1 0   1 1 1]</li><li>The determinant = 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L78-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_phi_varFF-NTuple{6, Any}" href="#TermStructureModels.post_phi_varFF-NTuple{6, Any}"><code>TermStructureModels.post_phi_varFF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">post_phi_varFF(yields, macros, mean_phi_const, rho, prior_kappaQ_, tau_n; phi, psi, psi_const, varFF, q, nu0, Omega0, kappaQ, kQ_infty, SigmaO, fix_const_PC1, data_scale)</code></pre><p>Full-conditional posterior sampler for <code>phi</code> and <code>varFF</code> </p><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is a output of function <code>prior_kappaQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output(3)</strong></p><p><code>phi</code>, <code>varFF</code>, <code>isaccept=Vector{Bool}(undef, dQ)</code></p><ul><li>It gives a posterior sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/gibbs.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_C-Tuple{}" href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prior_C(; Omega0::Vector)</code></pre><p>We translate the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Normal priors.  </p><p><strong>Output:</strong></p><ul><li>unscaled prior of <code>C</code> in the LDLt decomposition, <code>OmegaFF = inv(C)*diagm(varFF)*inv(C)&#39;</code></li></ul><p><strong>Important note</strong></p><p>prior variance for <code>C[i,:] = varFF[i]*variance of output[i,:]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_gamma-Tuple{Any, Any}" href="#TermStructureModels.prior_gamma-Tuple{Any, Any}"><code>TermStructureModels.prior_gamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prior_gamma(yields, p)</code></pre><p>There is a hierarchcal structure in the measurement equation. The prior means of the measurement errors are <code>gamma[i]</code> and each <code>gamma[i]</code> follows Gamma(1,<code>gamma_bar</code>) distribution. This function decides <code>gamma_bar</code> empirically. OLS is used to estimate the measurement equation and then a variance of residuals is calculated for each maturities. An inverse of the average residual variances is set to <code>gamma_bar</code>.</p><p><strong>Output</strong></p><ul><li>hyperparameter <code>gamma_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_phi0-Tuple{Any, Vector{T} where T, Any, Any, Any}" href="#TermStructureModels.prior_phi0-Tuple{Any, Vector{T} where T, Any, Any, Any}"><code>TermStructureModels.prior_phi0</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prior_phi0(mean_phi_const, rho::Vector, prior_kappaQ_, tau_n, Wₚ; psi_const, psi, q, nu0, Omega0, fix_const_PC1)</code></pre><p>This part derives the prior distribution for coefficients of the lagged regressors in the orthogonalized VAR. </p><p><strong>Input</strong></p><ul><li><code>prior_kappaQ_</code> is a output of function <code>prior_kappaQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output</strong></p><ul><li>Normal prior distributions on the slope coefficient of lagged variables and intercepts in the orthogonalized equation. </li><li><code>Output[:,1]</code> for intercepts, <code>Output[:,1+1:1+dP]</code> for the first lag, <code>Output[:,1+dP+1:1+2*dP]</code> for the second lag, and so on.</li></ul><p><strong>Important note</strong></p><p>prior variance for <code>phi[i,:]</code> = <code>varFF[i]*var(output[i,:])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_varFF-Tuple{}" href="#TermStructureModels.prior_varFF-Tuple{}"><code>TermStructureModels.prior_varFF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prior_varFF(; nu0, Omega0::Vector)</code></pre><p>We translate the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Inverse-Gamma priors.  </p><p><strong>Output:</strong></p><ul><li>prior of <code>varFF</code> in the LDLt decomposition,<code>OmegaFF = inv(C)*diagm(varFF)*inv(C)&#39;</code></li><li>Each element in the output follows Inverse-Gamma priors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/prior.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}" href="#TermStructureModels.yphi_Xphi-Tuple{Any, Any, Any}"><code>TermStructureModels.yphi_Xphi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">yphi_Xphi(PCs, macros, p)</code></pre><p>This function generate the dependent variable and the corresponding regressors in the orthogonalized transition equation.</p><p><strong>Output(4)</strong></p><p><code>yphi</code>, <code>Xphi = [ones(T - p) Xphi_lag Xphi_contemporaneous]</code>, <code>[ones(T - p) Xphi_lag]</code>, <code>Xphi_contemporaneous</code></p><ul><li><code>yphi</code> and <code>Xphi</code> is a full matrix. For i&#39;th equation, the dependent variable is <code>yphi[:,i]</code> and the regressor is <code>Xphi</code>. </li><li><code>Xphi</code> is same to all orthogonalized transtion equations. The orthogonalized equations are different in terms of contemporaneous regressors. Therefore, the corresponding regressors in <code>Xphi</code> should be excluded. The form of parameter <code>phi</code> do that task by setting the coefficients of the excluded regressors to zeros. In particular, for last <code>dP</code> by <code>dP</code> block in <code>phi</code>, the diagonals and the upper diagonal elements should be zero. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/empiricals.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ν-Tuple{Any, Any}" href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ν(i, dP; nu0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/82894d509381d144d8f816348db9010eab7f649b/src/EB_marginal.jl#L59-L61">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../others/">« Other Forms of the Model</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 19 February 2025 02:29">Wednesday 19 February 2025</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
